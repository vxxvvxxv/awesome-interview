[Source code](https://github.com/golang/go/blob/master/src/runtime/string.go).

---

**Строка в Go** — это **неизменяемая последовательность байт**, представляющая текст в кодировке **UTF-8**.

- Строки **не являются массивами символов** (как в C), а скорее **неизменяемыми (immutable) срезами байт**.
- Они могут содержать любые Unicode-символы (кириллица, эмодзи и т.д.).

```go
s := "Привет, 世界!" // Строка с кириллицей и иероглифами
```

**Для Unicode-символов** используйте `[]rune`, так как **длина строки** в байтах и символах может отличаться.

## Как они устроены?

[Источник](https://github.com/golang/go/blob/master/src/runtime/string.go#L282-L291).

```go
type string struct {
    data *byte  // Указатель на массив байт
    len  int    // Длина строки в байтах
}
```

- **Строка — это структура с указателем на байты и длиной**.
- Байты хранятся в памяти **неизменяемо/иммутабельно (immutable)** (как константы).

```go
Строка: "Go"
Байты: 0x47, 0x6F (ASCII-коды 'G' и 'o')
```

## Важные нюансы

**Длина строки (`len(s)`)** возвращает **количество байт**, а не символов:
```go
s := "世界"
fmt.Println(len(s)) // 6 (каждый иероглиф — 3 байта в UTF-8)
```
Для подсчета символов используйте `utf8.RuneCountInString(s)`.

**Итерация по строке**

- По байтам:
```go
for i := 0; i < len(s); i++ {
    fmt.Printf("%x ", s[i]) // Байты
}
```

- По символам (рунам):
```go
for _, r := range s {
    fmt.Printf("%c ", r) // Символы
}
```

## Почему строки в Go иммутабельны?

- **Безопасность**: Исключаются случайные изменения данных, которые могут использоваться в нескольких местах.
- **Потокобезопасность**: Не требуется синхронизация при чтении.
- **Эффективность**: Компилятор может оптимизировать хранение (например, интернирование строк).

**Пример проблемы изменяемости (если бы строки были mutable):**

```go
s1 := "Hello"
s2 := s1
// Если бы строки были изменяемы, модификация s1 могла бы повлиять на s2
```

### И если они иммутабельны, могу ли я изменить какой-то символ внутри?

**Нет, строки неизменяемы.** Попытка изменить символ по индексу приведет к ошибке:

```go
s := "Hello"
s[0] = 'h' // Ошибка: cannot assign to s[0]
```

#### Как обойти это?

**Их нельзя изменить напрямую**, но можно преобразовать в `[]byte` или `[]rune`, модифицировать и создать новую строку.

##### Способ 1: Преобразовать в `[]byte` (для ASCII и простых случаев)

**Ограничение**: Не подходит для Unicode-символов (например, "Привет"), так как один символ может занимать несколько байт.

```go
s := "Hello"
bytes := []byte(s)
bytes[0] = 'h'
s = string(bytes)
fmt.Println(s) // "hello"
```

#### Способ 2: Работа с `[]rune` (для Unicode)

**Почему `rune`?**

- `rune` в Go — это аналог `int32`, представляющий **Unicode-код символа**.
- Подходит для символов, занимающих больше 1 байта (кириллица, иероглифы).

```go
s := "Привет"
runes := []rune(s)
runes[0] = 'У' // Меняем первый символ
s = string(runes)
fmt.Println(s) // "Уривет" (если заменили 'П' на 'У')
```

#### Способ 3: Создание новой строки (безопасный метод)

```go
s := "Hello"
newS := "h" + s[1:] // Заменяем первый символ
fmt.Println(newS)    // "hello"
```

## Как происходит конкатенация? (этих самих иммутабельных строк)

В Go строки являются **неизменяемыми (immutable) последовательностями байт**, и конкатенация всегда создает **новую строку**, копируя данные из исходных. Разберём, как это работает на уровне памяти и компилятора.

### Способы конкатенации

- Базовая конкатенация через `+` - хорошо для **простых случаев** (компилятор оптимизирует).
- Конкатенация через `strings.Builder` - лучше для **конкатенации в циклах**.
- Конкатенация через `strings.Join` - идеально для **слайсов строк**.
- Конкатенация через `fmt.Sprintf` - для сложного форматирования, но не для скорости.

**Правило:**
- Если конкатенируете больше 5 строк или в цикле — используйте `strings.Builder`.

#### Базовая конкатенация через `+`

Когда вы пишете:

```go
s := "Hello" + " " + "World"
```

Компилятор Go оптимизирует это в **одну аллокацию**:

1. Вычисляет **общий размер** новой строки (в данном случае `5 + 1 + 5 = 11` байт).
2. Создает **новый массив байт** в памяти.
3. Копирует `"Hello"`, `" "`, `"World"` в этот массив.

##### Что под капотом?

Компилятор ([Источник](https://github.com/golang/go/blob/master/src/runtime/string.go#L26-L58)) преобразует это в вызов `runtime.concatstrings`:

```go
// concatstrings реализует Go string concatenation x+y+z+...
// Операнды передаются в срез a.
// Если buf! = nil, компилятор определил, что результат не избегает 
// вызывающей функции, тогда строковые данные могут быть сохранены в buf, 
// если они достаточно малы.
// ...
// concatstrings implements a Go string concatenation x+y+z+...
// The operands are passed in the slice a.
// If buf != nil, the compiler has determined that the result does not
// escape the calling function, so the string data can be stored in buf
// if small enough.
func concatstrings(buf *tmpBuf, a []string) string {
	idx := 0
	l := 0
	count := 0
	for i, x := range a {
		n := len(x)
		if n == 0 {
			continue
		}
		if l+n < l {
			throw("string concatenation too long")
		}
		l += n
		count++
		idx = i
	}
	if count == 0 {
		return ""
	}

	// Если есть только одна строка и либо ее нет в стеке
	// или наш результат не ускользает от вызывающего фрейма (buf! = nil),
	// тогда мы можем вернуть эту строку напрямую.
	// ...
	// If there is just one string and either it is not on the stack
	// or our result does not escape the calling frame (buf != nil),
	// then we can return that string directly.
	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
		return a[idx]
	}
	s, b := rawstringtmp(buf, l)
	for _, x := range a {
		n := copy(b, x)
		b = b[n:]
	}
	return s
}
```

##### Использование в цикле

Если конкатенация происходит в цикле, каждый `+` создает **новую строку**, что ведет к множественным аллокациям:

- **Медленно**: Каждый `+` копирует все байты заново.
- **Мусор (GC)**: Остаются временные строки, которые нужно утилизировать.

```go
var s string
for i := 0; i < 10; i++ {
    s += "x" // На каждой итерации создается новая строка!
}
```

#### Конкатенация через `strings.Builder`

Для эффективной конкатенации в циклах используется `strings.Builder`:

```go
var builder strings.Builder
for i := 0; i < 10; i++ {
    builder.WriteString("x")
}
s := builder.String() // Получаем итоговую строку
```

##### Как это работает?

- `strings.Builder` использует **неэкспортируемый буфер** (`[]byte`), который растет по необходимости (аналогично `append` для слайсов).
- При вызове `String()` создается строка **без копирования**, если буфер не изменялся после последнего вызова.

##### Как реализовать самому?

```go
type Builder struct {
    buf []byte
}

func (b *Builder) WriteString(s string) {
    b.buf = append(b.buf, s...)
}

func (b *Builder) String() string {
    return string(b.buf) // Преобразует []byte в string
}
```


#### Конкатенация через `strings.Join`

Идеально для объединения **слайса строк**.

**Плюсы:**
- Одна аллокация.
- Нет накладных расходов на `+` в цикле.

```go
parts := []string{"Hello", "World"}
s := strings.Join(parts, " ") // "Hello World"
```

#### Конкатенация через `fmt.Sprintf`

Удобно для сложного форматирования, но **медленнее**, из-за **парсинга формата**, **рефлексии** и **аллокаций**.

```go
s := fmt.Sprintf("%s %s", "Hello", "World")
```

[Источник](https://github.com/golang/go/blob/master/src/fmt/print.go#L236C1-L243C2).

```go
// Sprintf formats according to a format specifier and returns the resulting string.
func Sprintf(format string, a ...any) string {
	p := newPrinter()
	p.doPrintf(format, a)
	s := string(p.buf)
	p.free()
	return s
}
```

Описание `doPrintf` доступно в [исходниках](https://github.com/golang/go/blob/master/src/fmt/print.go#L1019) (_там очень много кода_). Там два вложенных `for`.

##### Как работает

Функция `fmt.Sprintf` использует **механизм форматирования** на основе интерфейса `fmt.Stringer`, рефлексии (`reflect`) и динамического парсинга строки формата.

###### **Основные этапы работы:**

1. **Парсинг строки формата** (например, `"Hello %s, your score is %d"`).
2. **Обработка аргументов** (проверка типов, преобразование значений).
3. **Буферизация результата** (постепенное формирование строки).

##### Почему это медленно?

###### Динамический парсинг формата

Каждый вызов `fmt.Sprintf` требует:

- Разбора строки формата (`"%s %d %f"`).
- Проверки **типов аргументов** в runtime (через `interface{}` и рефлексию).

```go
name := "Alice"
age := 30
s := fmt.Sprintf("%s is %d years old", name, age)
```

Здесь:

1. `%s` и `%d` обрабатываются в runtime.    
2. Проверяется, что `name` — строка, а `age` — число.

###### Использование `interface{}/any` и рефлексии

Аргументы передаются как `...interface{}`, что приводит к:

- **Боксингу (boxing)** для примитивов (например, `int` → `interface{}`).    
- **Динамической проверке типов** через `reflect`.

```go
// int преобразуется в interface{}, что требует аллокации
score := 100
fmt.Sprintf("Score: %d", score)  // Боксинг score
```

###### Буферизация через `bytes.Buffer`

В отличие от `strings.Builder`, `fmt.Sprintf` использует `bytes.Buffer`, который:

- Менее оптимизирован для строковых операций.    
- Требует преобразования `[]byte` → `string` в конце.

##### Когда использовать?

- **Сложное форматирование** (числа, даты, выравнивание).
- **Динамические шаблоны** (например, генерация SQL-запросов).
- **Логирование**, где удобство важнее скорости.

###### Как ускорить форматирование?

Если `fmt.Sprintf` стал узким местом:

1. **Замените на `strings.Builder`** для простых случаев.
```go
var builder strings.Builder
builder.WriteString("Hello ")
builder.WriteString(name)
s := builder.String()
```

2. **Заранее вычисляйте строки**, если формат статичен.
3. **Используйте `strconv` для чисел** вместо `%d`:
```go
s := "Score: " + strconv.Itoa(score)  // Быстрее, чем fmt.Sprintf
```

### Бенчмарк: Сравнение производительности

Результаты для 10 000 итераций (`go test -bench=.`):

```go
BenchmarkConcatPlus-8          1000   1,000,000 ns/op  // Медленно
BenchmarkConcatBuilder-8     100000      10,000 ns/op  // Быстро
BenchmarkConcatJoin-8        100000      12,000 ns/op  // Быстро
```

`+` в цикле **в 100 раз медленнее**, чем `strings.Builder`.

## Как посчитать количество символов в строке?

В Go строка — это последовательность **байт** (не символов!). Один символ (например, иероглиф или эмодзи) может занимать **от 1 до 4 байт** в UTF-8.

```go
s := "Привет, 世界!" 

// Длина в байтах (не символах!)
byteLen := len(s)  // 19 (кириллица и иероглифы занимают по 2-3 байта)

// Длина в символах (рунах)
runeLen := utf8.RuneCountInString(s)  // 10
```

### Почему `len(s)` не подходит?

```go
s := "世界"
fmt.Println(len(s))         // 6 (байт)
fmt.Println(len([]rune(s))) // 2 (символа)
```

## Что такое rune?

`rune` в Go — это **псевдоним для `int32`**, представляющий **Unicode-код символа** (Code Point).

- Используется для корректной работы с символами, выходящими за пределы ASCII (кириллица, эмодзи и т.д.).
- Одна `rune` может занимать **1–4 байта** в UTF-8.

```go
s := "A⌘世"
for _, r := range s {
    fmt.Printf("%c = %v (Unicode: U+%04X)\n", r, r, r)
}

// Output:
// A = 65 (Unicode: U+0041)
// ⌘ = 8984 (Unicode: U+2318)
// 世 = 19990 (Unicode: U+4E16)
```

## В чем разница прохода по строке range и индексом?

### `range` (рекомендуется для Unicode)

- Итерируется по **рунам** (символам), а не байтам.
- Корректно обрабатывает многобайтовые символы.
- Возвращает **позицию символа в байтах** и его **Unicode-код** (`rune`).

```go
s := "A⌘世"
for index, r := range s {
    fmt.Printf("Символ '%c' начинается с байта %d\n", r, index)
}

// Output:
// Символ 'A' начинается с байта 0
// Символ '⌘' начинается с байта 1
// Символ '世' начинается с байта 4
```

### индекс (только для ASCII или осторожно!)

- Итерируется по **байтам**, а не символам.
- Ломается на многобайтовых символах.

```go
s := "A⌘世"
for i := 0; i < len(s); i++ {
    fmt.Printf("Байт %d: %x\n", i, s[i])
}

// Output:
// Байт 0: 41  // 'A'
// Байт 1: e2  // Первый байт '⌘' (ошибка!)
// Байт 2: 8c  // Второй байт '⌘' (ошибка!)
// ...
```


