Полезные ссылки:
- [Go scheduler. Простыми словами](https://habr.com/ru/articles/743266/)
- [Dmitry Vyukov — Go scheduler: Implementing language with lightweight concurrency](https://www.youtube.com/watch?v=-K11rY57K7k)
- [Антон Сергеев, «Go под капотом»](https://www.youtube.com/watch?v=rloqQY9CT8I)
- [Планирование в Go: Часть I — Планировщик ОС](https://habr.com/ru/articles/478168/)
- [Планирование в Go: Часть II — Планировщик Go](https://habr.com/ru/articles/489862/)
- [Как устроен планировщик в Golang | Олег Козырев, Авито](https://www.youtube.com/watch?app=desktop&v=8z6FAaNPA-M)
- [Планировщик Go — самый подробный гайд простым языком](https://www.youtube.com/watch?v=kedW1xO3Zbo)

---

# Модели многозадачности

| **Критерий**             | **Кооперативная**             | **Вытесняющая**                         |
| ------------------------ | ----------------------------- | --------------------------------------- |
| **Управление задачами**  | Задачи сами отдают управление | Планировщик принудительно останавливает |
| **Стабильность**         | Низкая (зависание возможно)   | Высокая                                 |
| **Накладные расходы**    | Низкие                        | Высокие                                 |
| **Сложность реализации** | Простая                       | Сложная                                 |
| **Примеры**              | Windows 3.x, DOS-приложения   | Linux, Windows 10, iOS                  |
| **Использование**        | Встроенные системы, старые ОС | Современные ОС, серверы, игры           |

## Кооперативная

Задачи (процессы/потоки) **добровольно передают управление** планировщику, например, через вызов `yield()`. Пока задача не отдаст управление, другие задачи не выполняются.

### Плюсы

- **Низкие накладные расходы**:
	- Переключение контекста происходит только в точках явного «отпускания» управления.
	- Пример: В играх 90-х (например, _SimCity_) задачи обновления графики и физики переключались быстро, так как код был оптимизирован.
- **Простота реализации**:
	- Не требуется сложный планировщик.
	- Пример: Ранние версии Windows (3.x) использовали кооперативную многозадачность для приложений.
- **Предсказуемость**:
	- Программист точно знает, когда произойдет переключение.
	- Пример: Встроенные системы с жесткими временными ограничениями.

### Минусы

- **Риск зависания системы**:
	- Если задача не вызывает `yield()`, система блокируется.
	- Пример: В Windows 3.x зависшее приложение «замораживало» весь компьютер.
- **Несправедливое распределение ресурсов**:
	- Одна «жадная» задача может монополизировать процессор.
	- Пример: Долгие вычисления в фоновом потоке без `yield()` блокируют интерфейс.
- **Сложность отладки**:
	- Ошибки в одной задаче влияют на всю систему.

### Примеры использования

- **Игры и приложения реального времени**:
	- Где требуется полный контроль над выполнением кода (например, _DOOM_ на MS-DOS).
- **Микроконтроллеры**:
	- Системы без ОС, где задачи работают в бесконечном цикле с ручным управлением.

## Вытесняющая

Планировщик **принудительно останавливает задачи** через определенные интервалы времени или приоритеты, не дожидаясь их согласия.

### Плюсы

- **Стабильность**:
	- Даже «зависшая» задача не блокирует систему.
	- Пример: Современные ОС (Linux, Windows) не зависают из-за одного приложения.
- **Справедливое распределение ресурсов**:
	- Планировщик гарантирует, что все задачи получат процессорное время.
	- Пример: Серверы, где важно обслуживать множество клиентов одновременно.
- **Изоляция задач**:
	- Ошибки в одной задаче не влияют на другие.

### Минусы

- **Высокие накладные расходы**:
	- Частые переключения контекста требуют ресурсов.
	- Пример: В реальном времени (например, робототехника) это может приводить к задержкам.
- **Сложность синхронизации**:
	- Нужны механизмы блокировок (мьютексы, семафоры) для защиты общих данных.
	- Пример: Race conditions в многопоточных приложениях.
- **Непредсказуемость**:
	- Программист не контролирует момент переключения задач.

### Примеры использования

- **Современные операционные системы**:
	- Windows, Linux, macOS — все используют вытесняющую многозадачность.
- **Серверные приложения**:
	- Веб-серверы (например, Nginx) обрабатывают тысячи соединений параллельно.
- **Игры с многопоточностью**:
	- Распределение рендеринга, физики и AI по разным потокам.

## Модель многозадачности в Go

Полезные ссылки:
- [GO Scheduler: теперь не кооперативный?](https://habr.com/ru/articles/502506/)

В Go используется **гибридный подход**:

- **Кооперативные элементы**: Горутины могут добровольно отдавать управление через `runtime.Gosched()`.
- **Вытеснение**:
	- Горутины автоматически вытесняются при блокировке (каналы, I/O).
    - Начиная с Go 1.14, горутины **"в аварийном режиме"** вытесняются асинхронно (на основе прерываний).

### Пример

```go
// Кооперативное переключение
go func() {
    for {
        // Долгие вычисления
        runtime.Gosched() // Явное освобождение CPU
    }
}()

// Вытеснение при блокировке
go func() {
    data := <-ch // Блокировка → планировщик переключается на другую горутину
}()
```

# Что такое GMP-модель?

Полезные ссылки:
- [Analysis of Golang GPM Models](https://www.sobyte.net/post/2022-07/go-gmp/#2-life-cycle-of-m)

**GMP** — это архитектура планировщика Go, которая управляет горутинами, потоками ОС и распределением ресурсов. Она обеспечивает высокую производительность и эффективную конкурентность.

## Что означает каждая буква?

### Коротко

- **G** — ваши горутины.
- **M** — потоки ОС, которые выполняют код.
- **P** — логические процессоры, которые распределяют **G** между **M**.

### Детальнее

| Компонент | Описание                                                                                                                                                                                                                                                                                                                                                                    |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **G**     | **Goroutine** — горутины, легковесная «нить» выполнения. Не поток ОС, а абстракция Go, требующая минимум ресурсов (2 КБ стека на старте, динамически растёт).<br><br>На каждом **P** должна выполняться **G** и scheduler за этим следит.                                                                                                                                   |
| **M**     | **Machine (OS Thread)** — поток операционной системы. Именно **M** выполняет код горутин. Каждый **M** привязан к ядру CPU.<br>Каждый **P** работает на потоке из **M**. <br><br>Заметьте, что **P** не всегда равно **M**, например, поток может быть заблокирован `syscall`'ом и тогда для его **P** будет выделен другой поток. А еще есть CGO и прочие и прочие нюансы. |
| **P**     | **Processor (логический процессор)** — виртуальный ресурс, который управляет очередями горутин и связывает **M** с **G**. Количество **P** равно `GOMAXPROCS`  (их количество мы можем поменять функцией `runtime.GOMAXPROCS`, по умолчанию — число ядер CPU).<br><br>На каждом логическом процессоре в один момент времени может независимо выполняться одна горутина.     |

## Как взаимодействуют между собой?

### Базовая схема работы

1. **P** создается в количестве `GOMAXPROCS` (например, 4 для 4-ядерного CPU).
2. Каждый **P** имеет локальную очередь (**local runqueue**) горутин (**G**), готовых к выполнению.
3. **M** (поток ОС) «цепляется» к **P** и выполняет горутины из его очереди.
4. Если локальная очередь **P** пуста, он «крадет» горутины из очереди другого **P** (**work-stealing**).

#### Пример

```go
func main() {
    go task1() // G1 создается и попадает в очередь P1
    go task2() // G2 попадает в очередь P1
    time.Sleep(time.Second)
}

func task1() { /*...*/ } // G1
func task2() { /*...*/ } // G2
```

1. При старте программы создаются **P1**, **P2**, ..., **Pn** (по количеству ядер).
2. **M1** (поток ОС) связывается с **P1** и начинает выполнять горутины из его очереди.
3. Если **G1** блокируется (например, на I/O), **M1** отсоединяется от **P1**, чтобы не простаивать, и создает новый поток **M2** для обработки других горутин.

### Динамическое взаимодействие компонентов

#### Блокировка горутины (например, вызов time.Sleep, I/O)

1. **G** (например, `G1`) блокируется.
2. **M1** отсоединяется от **P1** и освобождает поток ОС.
3. **P1** переключается на другую горутину (`G2`) из своей очереди.
4. Когда `G1` разблокируется, она возвращается в очередь **P1** (или другого **P**).

#### Системный вызов (например, работа с файлом)

1. **G** выполняет блокирующий системный вызов.
2. Планировщик Go создает новый **M** (поток ОС), чтобы не терять ресурсы **P**.
3. После завершения системного вызова **G** возвращается в очередь.

#### Каналы (channels) и синхронизация

- Если **G** ожидает данные из канала, она переходит в режим ожидания и освобождает **M**, который может выполнять другие **G**.

## Преимущества GMP-модели

- **Масштабируемость**:
	- Тысячи горутин работают на небольшом числе потоков ОС.
- **Эффективность CPU**:
	- **P** и work-stealing минимизируют простои потоков.
- **Низкие накладные расходы**:
	- Переключение горутин происходит в пространстве пользователя, без участия ядра ОС.

## Пример: Как GMP обрабатывает 10 000 горутин

1. Создаются 10 000 **G** (горутин).
2. Они распределяются по локальным очередям **P** (например, 4 **P** для 4 ядер).
3. Каждый **M** (поток ОС) выполняет горутины из очереди своего **P**.
4. Если одна **G** блокируется, **M** не простаивает — переключается на другую **G**.

# Очереди

TODO

## Что такое локальная очередь?

TODO

## Что такое глобальная очередь?

TODO

## Что такое work-stealing? 

TODO

### Почему он используется там?

TODO

### Почему не work-sharing?

TODO

## В какой момент goroutine переключаются?

TODO

## Что такое netpool-ер?

TODO

### Какую роль играет?

TODO

## Что такое sysmon?

TODO

### Какую роль играет?

TODO

## Что происходит с goroutine, когда она вызывает syscall?

TODO
