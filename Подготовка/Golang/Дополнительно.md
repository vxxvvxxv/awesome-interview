# Про Go

## Плюсы в Go

- Конкурентность. 
- Вытесняющая модель.

## Минусы GO

- Каждый инстанс тащит за собой весь runtime Go (~ 5 mb).

## Что огорчает в системе типов в Go?

- Отсутствие ковариантности и контравариантности:
	- когда нужно перекастить slice одних интерфейсов в другой slice интерфейсов.

## Go императивный или декларативный?

Go - императивный.

### В чём разница?

- Императивный - говоришь программе что сделать.
	- Go и т.д.
- Декларативный - говоришь программе как это сделать.
	- HTML, CSS и т.д.

## Какие средства обобщённого программирования в Go?

- Interface
- Generic
- Кодогенерация
- Рефлексия

## Что такое sum types?

// TODO

### Как реализовать в Go?

// TODO

## Что такое defer

Это отложенный вызов, будет вызван в моменте выхода из контекста текущей функции. Будет завершаться в порядке FILO. Будет выполнен до возврата результата (до return).

### Зачем нужен?

- Помогает (_не забыть_) закрыть соединения/открытые файлы перед завершением функции.
- Он помогает обработать ситуации с **panic**, через функцию `recover()`.

## Есть ли в Go деструкторы?

**Можно сказать, что - нет**. Максимум, чем мы пользуемся на практике - это `defer`. 
Но, мало кто знает, что в Go есть **финалайзеры (`finalizer`)**, но на практике (*почти*) никто ими не пользуется.

`finalizer` - используется в GC перед очисткой (когда все ссылки пропали на объект через finalizer).
Также можем сами реализовать finalizer у структуры, через `runtime.SetFinalizer`, [пример1](https://gist.github.com/deltamobile/6511901):

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

type Foo struct {
	name string
	num  int
}

func finalizer(f *Foo) {
	fmt.Println("a finalizer has run for ", f.name, f.num)
}

var counter int

func MakeFoo(name string) (a_foo *Foo) {
	a_foo = &Foo{name, counter}
	counter++
	runtime.SetFinalizer(a_foo, finalizer)
	return
}

func Bar() {
	f1 := MakeFoo("one")
	f2 := MakeFoo("two")

	fmt.Println("f1 is: ", f1.name)
	fmt.Println("f2 is: ", f2.name)
}

func main() {
	for i := 0; i < 3; i++ {
		Bar()
		time.Sleep(time.Second)
		runtime.GC()
	}
	fmt.Println("done.")
}

```
