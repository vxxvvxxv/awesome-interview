# ООП (Объектно-ориентированное программирование)

## Что это

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на представлении программы как совокупности **объектов**, которые взаимодействуют друг с другом. Каждый объект — это экземпляр **класса**, содержащего **данные** (поля) и **поведение** (методы).

## Основные концепции ООП

1. **Инкапсуляция** — скрытие внутренней реализации объекта, доступ только через интерфейс (методы).
2. **Наследование** — возможность создавать новые классы на основе существующих.
3. **Полиморфизм** — способность объектов использовать один интерфейс, но разную реализацию.
4. **Абстракция** — выделение существенного, скрытие деталей.

## Плюсы ООП

- **Повторное использование кода** (через наследование).
- **Модульность** (программу легко разбить на независимые классы).
- **Упрощение поддержки и расширяемости кода**.
- **Естественное моделирование реальных сущностей**.

##  Минусы ООП

- **Избыточность** при простых задачах.
- **Сложность проектирования архитектуры** (легко сделать плохо).
- **Производительность** (ООП может быть медленнее из-за абстракций).
- **Множественное наследование** (в языках, где оно разрешено) может приводить к конфликтам.

## ООП в Go

Go не является классическим объектно-ориентированным языком, как Java или C++, но он реализует **некоторые принципы ООП**.

| Концепция ООП | Есть в Go?  | Как реализуется                  |
| ------------- | ----------- | -------------------------------- |
| Инкапсуляция  | ✅           | Через экспорт/неэкспорт и методы |
| Наследование  | ⚠️ Частично | Через композицию (embedding)     |
| Полиморфизм   | ✅           | Интерфейсы                       |
| Абстракция    | ✅           | Интерфейсы, композиция           |

### Что есть в Go

#### Композиция вместо наследования (встраивание)

Go не поддерживает наследование в классическом смысле. Вместо этого используется **встраивание (embedding)** — когда одна структура включает другую, унаследовав её методы.

```go
type Animal struct {
    Name string
}

func (a Animal) Speak() {
    fmt.Println(a.Name + " makes a sound")
}

type Dog struct {
    Animal
}

func main() {
    d := Dog{Animal{"Rex"}}
    d.Speak() // Rex makes a sound
}
```

#### Интерфейсы и полиморфизм

Интерфейсы в Go позволяют достичь **полиморфизма**. Если тип реализует все методы интерфейса — он считается его реализацией (без явного указания).

```go
type Speaker interface {
    Speak()
}

func MakeItSpeak(s Speaker) {
    s.Speak()
}
```

#### Инкапсуляция

В Go **первый символ имени** определяет уровень доступа:
- с **заглавной буквы** — экспортируется (публично),
- с **маленькой** — приватно (в пределах пакета).

#### Абстракция

Через интерфейсы и скрытие деталей реализации — Go позволяет описывать поведение без указания конкретных типов.

### Что отсутствует в Go

- **Классы и наследование** (в классическом смысле).
- **Перегрузка методов и операторов**.
- **Множественное наследование** (что, кстати, многие считают плюсом — проще и безопаснее).

### Пример

```go
package main

import "fmt"

// Интерфейс
type Speaker interface {
	Speak()
}

// Структура
type Dog struct {
	Name string
}

// Метод для структуры Dog
func (d Dog) Speak() {
	fmt.Println(d.Name, "says Woof!")
}

// Ещё одна структура
type Cat struct {
	Name string
}

func (c Cat) Speak() {
	fmt.Println(c.Name, "says Meow!")
}

// Функция, принимающая любой тип, реализующий интерфейс Speaker
func MakeSpeak(s Speaker) {
	s.Speak()
}

func main() {
	d := Dog{"Rex"}
	c := Cat{"Mittens"}

	MakeSpeak(d)
	MakeSpeak(c)
}

// Output:
// Rex says Woof!
// Mittens says Meow!
```

# Interface

## Что такое `interface` в Go?

Интерфейс в Go — это **набор методов**. Если тип реализует все методы интерфейса — он **автоматически** считается реализацией интерфейса.

Например:

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

Любой тип, у которого есть метод `Read([]byte) (int, error)`, реализует `Reader`.

## Как устроены интерфейсы внутри

Интерфейс — это **двойка**:

1. **Type (или type descriptor)** — информация о реальном типе, который под капотом.
2. **Value (или data)** — сам "объект".

```go
interface {
    tab  *itab  // типовая информация
    data unsafe.Pointer // данные
}
```

Это важно для понимания `nil interface`, см. ниже.

## Что такое duck typing

**Duck typing** (утинная типизация) — концепция из динамически типизированных языков (Python, Ruby и т.п.), но в Go она **реализована статически** через интерфейсы.

> "If it walks like a duck and quacks like a duck, it’s a duck."
> _"Если это ходит как утка и квакает как утка, значит это утка."_

**Go** применяет **структурную типизацию**, а не номинативную, то есть:

- Тип реализует интерфейс **автоматически**, если содержит нужные методы.

Это и есть **Duck Typing**, но со **строгой проверкой на этапе компиляции**.

### Пример

```go
type Duck interface {
	Quack()
	Walk()
}

type RobotDuck struct{}

func (r RobotDuck) Quack() { fmt.Println("Robot: Quack") }
func (r RobotDuck) Walk()  { fmt.Println("Robot: Walk") }

func letItBeADuck(d Duck) {
	d.Quack()
	d.Walk()
}

func main() {
	var d Duck = RobotDuck{} // НЕ надо явно указывать реализацию
	letItBeADuck(d)
}
```

## Приведение одного интерфейса к другому

Это работает **если реальный тип внутри** реализует оба интерфейса.

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Closer interface {
	Close() error
}

type ReadCloser interface {
	Reader
	Closer
}

func DoSomething(i interface{}) {
	if rc, ok := i.(ReadCloser); ok {
		fmt.Println("i implements ReadCloser")
		// используем rc.Read() и rc.Close()
	}
}
```

### Проверка типа интерфейса — `type assertion`

```go
var i interface{} = "hello"

s := i.(string)      // ОК, если уверен, что там string
s, ok := i.(string)  // Без паники, безопасный вариант

fmt.Println(s, ok) // "hello true"
```

### `type switch` — проверка конкретного типа

```go
func checkType(i interface{}) {
	switch v := i.(type) {
	case string:
		fmt.Println("String:", v)
	case int:
		fmt.Println("Int:", v)
	default:
		fmt.Println("Unknown type")
	}
}
```

## Не очевидные кейсы с `nil interface`

### Интерфейс не `nil`, если тип есть, но значение nil

```go
type Cat struct {
	Name string
}

func (c *Cat) Speak() {
	fmt.Println("meow")
}

func GetCat() Speaker {
	var c *Cat = nil
	return c // ВНИМАНИЕ: интерфейс НЕ nil!
}

func main() {
	s := GetCat()
	fmt.Println(s == nil) // false (!)
	s.Speak()             // panic: runtime error: invalid memory address
}
```

Почему? Потому что интерфейс содержит информацию о типе (`*Cat`), но значение `nil`. То есть:

- `type != nil`
- `value == nil`

А `interface == nil` **только когда оба nil**.

## Негативные кейсы с `nil interface`

### Ошибка сравнения

```go
func check(s Speaker) {
	if s == nil {
		fmt.Println("nil speaker")
	} else {
		fmt.Println("not nil") // попадём сюда даже если s содержит nil pointer!
	}
}
```

### `panic` при вызове метода на `nil` внутри интерфейса

```go
var c *Cat = nil
var s Speaker = c

s.Speak() // panic!
```

#### Как избегать

Проверяй и тип, и значение:

```go
if s == nil || reflect.ValueOf(s).IsNil() {
	// точно nil
}
```

или делай `type assertion`, а потом проверяй:

```go
if cat, ok := s.(*Cat); ok && cat == nil {
	// nil внутри
}
```

