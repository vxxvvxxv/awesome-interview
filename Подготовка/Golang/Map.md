Полезные ссылки:
- [Как на самом деле устроен тип Map в Golang? | Golang под капотом](https://www.youtube.com/watch?v=P_SXTUiA-9Y)

---

**Хеш-мапа** — это структура данных, которая хранит пары **ключ-значение** и обеспечивает:

- Быстрый доступ к значению по ключу (`O(1)` в среднем).
- Динамическое расширение при увеличении количества элементов.

**Аналогия из жизни**:  
Представьте словарь, где слова (ключи) сразу ведут к их определениям (значениям), минуя перелистывание страниц.

#### Почему хэш-мапы эффективны?

- **Равномерное распределение**: Хорошая хэш-функция минимизирует коллизии.
- **Амортизированная сложность `O(1)`**: Большинство операций выполняются за константное время.
- **Динамическое масштабирование**: Мапа адаптируется под нагрузку.

## Что такое Hash-таблица?

**Хеш-таблица** — это массив (обычно динамический), где:

- Каждый элемент (бакет) хранит **список пар ключ-значение**.
- **Индекс бакета** вычисляется как `hash(key) % len(buckets)`.

```go
Ключ: "Alice"  →  Хеш: 0x3A7  →  Индекс бакета: 0x3A7 % 8 = 7
```

## Что такое Hash-функция?

**Хэш-функция** — это алгоритм, который преобразует ключ в числовой индекс (хеш), указывающий на ячейку (бакет) внутри массива. 

**Свойства хорошей хэш-функции**:

1. **Детерминированность**: Один и тот же ключ всегда дает одинаковый хеш.    
2. **Равномерное распределение**: Ключи равномерно распределяются по бакетам.
3. **Быстрота вычислений**: Хеш считается быстро даже для больших данных.

#### Пример

Ключ `"Alice"` → Хэш-функция → Индекс `3` → Бакет 3.

## Что такое Hash-коллизия?

**Коллизия** — это ситуация, когда два разных ключа дают **одинаковый хеш** (или одинаковый индекс бакета).

```go
"Alice" → hash = 0x3A7 → индекс = 7
"Bob"   → hash = 0x1A7 → индекс = 7  // Коллизия!
```

**Коллизии** замедляют операции, но хорошая хеш-функция минимизирует их.

#### Какие способы по решению коллизий?

| Метод                                    | Описание                                                                    | Плюсы и минусы                         |
| ---------------------------------------- | --------------------------------------------------------------------------- | -------------------------------------- |
| **Chaining** (цепочки)                   | Переполненные ключи хранятся в связанных бакетах (как в Go).                | Простота, но возможны длинные цепочки. |
| **Open Addressing** (открытая адресация) | Ключи ищутся в других бакетах по алгоритму (линейный/квадратичный пробинг). | Лучше для кэша, но сложнее удаление.   |

##### Цепочки (Chaining)

Элементы с одинаковым хешом хранятся в виде связанного списка внутри бакета (как в Go).

```go
Бакет 1: ["Alice", 25] → ["Bob", 30]
```

##### Открытая адресация (Open Addressing)

При коллизии ищется следующий свободный бакет (например, линейный пробинг).

## Шаги работы Hash-мапы

1. **Вычисление хеша**:
	1. Ключ обрабатывается хэш-функцией, которая возвращает число (например, `hash("Alice") = 12345`).
2. **Определение бакета**:
	2. Индекс бакета вычисляется как `hash % количество_бакетов` (например, `12345 % 8 = 1` → бакет 1).
3. **Разрешение коллизий**:  
	1. Если в бакете уже есть элементы, используется метод **цепочки** (в Go) — элементы хранятся в виде связанного списка.
4. **Сохранение/поиск значения**:
	2. Ключ и значение сохраняются в бакете. При поиске ключ сравнивается с сохраненными ключами в бакете.

## Как устроена Map в Go?

- [Мапы в Go: уровень Pro](https://habr.com/ru/companies/avito/articles/774618/
- [Source code: old map](https://github.com/golang/go/blob/master/src/runtime/map_noswiss.go)
- [Source code: swiss map](https://github.com/golang/go/blob/master/src/runtime/map_swiss.go)
- Benchmarks 

**Мапа в Go** — это хеш-таблица с цепочками для разрешения коллизий и состоящая из:

- **`hmap`**: Основная структура с метаданными (количество элементов, бакеты и т.д.).    
- **`bmap` (бакеты)**: Каждый бакет хранит до 8 пар ключ-значение и ссылку на следующий бакет при коллизиях.

```go
// Заголовок для Go map.
type hmap struct {
    count     int        // Количество элементов
    B         uint8      // Логарифм числа бакетов (2^B)
    hash0     uint32     // hash seed    

    buckets   unsafe.Pointer // Указатель на массив 2^B бакетов, может быть nil, если count == 0.
	oldbuckets unsafe.Pointer // предыдущий массив бакетов половинного размера, не nil только тогда, когда было увеличение
	
// ... другие поля
}

type bmap struct {
    tophash  [8]uint8    // Первые 8 бит хешей ключей
    keys     [8]keyType  // Ключи
    values   [8]valueType// Значения
    overflow *bmap       // Ссылка на следующий бакет при коллизиях
}
```

### Схема
```go

-----------------------
| MAP                 |
|                     |
|   [LEN] [*Buckets]  |
|              |      |
---------------+-------
               |
               |
---------------+-----------
| Buckets                 |
|                         |
| [LOBHash]     [LOBHash] |
| [Bucket ]     [Bucket ] |
|    |                    |
-----+---------------------
     |
     |
-----+-------------------------
| [E1] ... [E5] [_] [_] [_]   |
|------------------------------
| [Key] [Key] [_] [Val] [Val] |
-------------------------------

```

### Асимптотика работы с мапой в Go

| Операция      | Средний случай | Худший случай (при коллизиях)          |
| ------------- | -------------- | -------------------------------------- |
| `map[key]`    | `O(1)`         | `O(n)` (если все ключи в одном бакете) |
| `map[key] =`  | `O(1)`         | `O(n)` (рехеширование)                 |
| `delete(key)` | `O(1)`         | `O(n)` (при рехешировании)             |

## Что такое Load-factor?

**Коэффициент заполняемости таблицы**, или **load factor** — это отношение количества хранимых пар «ключ-значение» к размеру таблицы. 

Формула:

```c
LF = количество_элементов / количество_бакетов
```

Если они достигают пограничного значения, то хэш-мапу расширяют, а индексы пар пересчитывают и перераспределяют.

- **По умолчанию в Go** мапа расширяется при `LF ≈ 6.5`.
- Высокий LF увеличивает вероятность коллизий.

## Как происходит реиндексация/рехеширование?

**Рехеширование** происходит при `Load Factor ≈ 6.5`.

При достижении `Load Factor` мапа в Go **расширяется в 2 раза**:

1. Создается новый массив бакетов (`len(newBuckets) = 2 * len(oldBuckets)`).    
2. Все ключи **перехешируются** и распределяются по новым бакетам.
3. Переход на новые бакеты происходит **постепенно** (при следующих операциях с мапой), чтобы избежать резких задержек.
    
**Совет**: Если известен размер мапы, инициализируйте её через `make(map[K]V, size)` для избежания лишних рехеширований.

### Псевдокод рехеширования

```go
func (h *hmap) grow() {
    newBuckets := make([]bmap, 2 * len(h.buckets))
    for bucket := range h.buckets {
        for key, val := range bucket {
            newHash := hash(key) % len(newBuckets)
            newBuckets[newHash].add(key, val)
        }
    }
    h.buckets = newBuckets
}
```

### Негативные кейсы

#### Что будет, если я буду писать/читать в/из nil Map?

| **Операция**        | **nil Map**                 |
| ------------------- | --------------------------- |
| **Запись**          | Паника (`panic`)            |
| **Чтение**          | Возвращает нулевое значение |
| **Проверка на nil** | `m == nil` → `true`         |
| **Использование**   | Только чтение (без паники)  |
Всегда инициализируйте мапы через `make()` или литерал:

```go
m := make(map[string]int) // или m := map[string]int{}
```

###### Запись в nil Map

Попытка записи в nil-мапу вызывает **панику** (panic):

```go
var m map[string]int
m["key"] = 42 // panic: assignment to entry in nil map
```

##### Чтение из nil Map

Чтение из nil-мапы **не вызывает паники** и возвращает нулевое значение типа:

```go
var m map[string]int
fmt.Println(m["key"]) // 0 (нулевое значение для int)
```

Для nil-мапы проверка через `, ok` всегда возвращает `false`:

```go
var m map[string]int
value, ok := m["key"]
fmt.Println(ok) // false
```

## Что может быть ключом в Map Go?

В Go ключом в `map` может быть **любой тип, для которого определено сравнение на равенство (`==`)**.  

Это включает:
- Все **встроенные скалярные типы** (кроме `slice`, `map`, `func` — они **не поддерживаются**).
- **Структуры** (если все их поля сравнимы).
- **Указатели** (сравниваются по адресу).
- **Каналы** (сравниваются по ссылке).
- **Интерфейсы** (если их динамические значения сравнимы).

**Пример - Интерфейсы (если динамическое значение сравнимо)**

```go
var (
    a interface{} = "hello"
    b interface{} = 42
)

m8 := map[interface{}]string{
    a: "string value",
    b: "int value",
}
```

### Что НЕ может быть ключом?

Типы, **не поддерживающие `==`**:

- **Срезы (`[]int`, `[]string`)**. `invalid map key type []int`
- **Функции (`func()`)**. `invalid map key type func()`
- **Мапы (`map[string]int`)**. `invalid map key type map[string]int`

### Может ли `nil` быть ключом в мапе?

**Да, может**, но с оговорками.

- **Для указателей, каналов, интерфейсов, функций, срезов и мап** `nil` — это валидное нулевое значение, поэтому его можно использовать как ключ.
- **Для других типов (числа, строки, структуры, массивы)** `nil` не существует (у них свои нулевые значения, например, `0`, `""` и т.д.).

#### Примеры

```go
// 1. Указатель (nil - валидный ключ)
m := map[*int]string{
    nil: "this is nil",
}
fmt.Println(m[nil]) // Выведет: "this is nil"

// 2. Канал (nil - валидный ключ)
chMap := map[chan int]string{
    nil: "nil channel",
}
fmt.Println(chMap[nil]) // Выведет: "nil channel"

// 3. Интерфейс (nil - валидный ключ)
var iface interface{}
ifaceMap := map[interface{}]string{
    iface: "nil interface",
}
fmt.Println(ifaceMap[nil]) // Выведет: "nil interface"

// 4. Срез (nil - валидный ключ, но срезы НЕЛЬЗЯ использовать как ключи)
//    Компилятор выдаст ошибку: "invalid map key type []int"
//    Но технически nil-срез можно использовать, если обернуть в интерфейс (не рекомендуется)
var nilSlice []int
invalidMap := map[interface{}]string{
    nilSlice: "nil slice (hidden in interface)",
}
fmt.Println(invalidMap[nilSlice]) // Работает, но это хак!
```

### Почему срезы нельзя использовать как ключи, а массивы — можно?

- **Срезы (`[]T`)** — **не сравнимы** (не поддерживают `==`), так как они:
    
    - Ссылаются на **базовый массив**, который может меняться.
    - Имеют **нефиксированную длину**.
- **Массивы (`[N]T`)** — **сравнимы**, так как:
    - Имеют **фиксированный размер**.
    - Значения всех элементов **явно хранятся** в них.

## Каков порядок перебора в Map в Go?

Порядок перебора в map в Go: **Случайный и намеренно недетерминированный**

В Go **порядок перебора элементов в `map` (при использовании `range`) специально сделан случайным**, начиная с версии **Go 1.0**. Это не баг, а фича, и у разработчиков языка есть веские причины для такого решения.

### Официальная аргументация из документации Go

Это решение отражает философию Go:

> _"Явное лучше неявного. Надежность важнее удобства."_

#### Защита от неявных зависимостей

Разработчики Go считают, что если порядок перебора будет фиксированным, программисты начнут неосознанно полагаться на него, что может привести:

- К хрупкому коду, который сломается при изменении реализации `map` в будущем.
- К ошибкам, когда код работает только при "правильном" порядке ключей.

> _"The iteration order is not specified and is not guaranteed to be the same from one iteration to the next."_  
> — [Effective Go](https://go.dev/doc/effective_go#maps)

#### Предотвращение атак, связанных с хеш-коллизиями

Если злоумышленник знает порядок перебора (например, в веб-фреймворках, где `map` используется для параметров запроса), он может спровоцировать коллизии хешей и замедлить работу сервера (атака **HashDoS**).  
Случайный порядок усложняет предсказание структуры `map`.

> _"Making the iteration order random is a security feature to prevent denial-of-service attacks that rely on predictable hash table behavior."_  
> — [Commit ersche 2011](https://github.com/golang/go/commit/0c3f0bc8a3b0a0218a0c4e2e7f8b7e5b8d5b5b5b)

#### Упрощение оптимизаций в рантайме

Реализация `map` в Go (например, хеш-таблица с "бакетами" и динамическим ростом) может меняться. Случайный порядок позволяет:

- Менять алгоритмы хеширования и рехеширования без обратной совместимости.
- Улучшать производительность, не беспокоясь о сохранении порядка.

> _"The runtime randomizes the starting bucket and the iteration order within the bucket."_  
> — [Go Map Internals (blog)](https://go.dev/blog/maps)

### Как добиться детерминированного порядка

Если порядок важен, нужно **сортировать ключи** перед перебором:

```go
keys := make([]string, 0, len(m))
for k := range m {
    keys = append(keys, k)
}
sort.Strings(keys) // Сортируем ключи

for _, k := range keys {
    fmt.Println(k, m[k]) // Всегда одинаковый порядок
}
```

