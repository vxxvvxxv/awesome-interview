Полезные ссылки:
- [Как на самом деле устроен тип Map в Golang? | Golang под капотом](https://www.youtube.com/watch?v=P_SXTUiA-9Y)

---

**Хеш-мапа** — это структура данных, которая хранит пары **ключ-значение** и обеспечивает:

- Быстрый доступ к значению по ключу (`O(1)` в среднем).
- Динамическое расширение при увеличении количества элементов.

**Аналогия из жизни**:  
Представьте словарь, где слова (ключи) сразу ведут к их определениям (значениям), минуя перелистывание страниц.

#### Почему хэш-мапы эффективны?

- **Равномерное распределение**: Хорошая хэш-функция минимизирует коллизии.
- **Амортизированная сложность `O(1)`**: Большинство операций выполняются за константное время.
- **Динамическое масштабирование**: Мапа адаптируется под нагрузку.

## Что такое Hash-таблица?

**Хеш-таблица** — это массив (обычно динамический), где:

- Каждый элемент (бакет) хранит **список пар ключ-значение**.
- **Индекс бакета** вычисляется как `hash(key) % len(buckets)`.

```go
Ключ: "Alice"  →  Хеш: 0x3A7  →  Индекс бакета: 0x3A7 % 8 = 7
```

## Что такое Hash-функция?

**Хэш-функция** — это алгоритм, который преобразует ключ в числовой индекс (хеш), указывающий на ячейку (бакет) внутри массива. 

**Свойства хорошей хэш-функции**:

1. **Детерминированность**: Один и тот же ключ всегда дает одинаковый хеш.    
2. **Равномерное распределение**: Ключи равномерно распределяются по бакетам.
3. **Быстрота вычислений**: Хеш считается быстро даже для больших данных.

#### Пример

Ключ `"Alice"` → Хэш-функция → Индекс `3` → Бакет 3.

## Что такое Hash-коллизия?

**Коллизия** — это ситуация, когда два разных ключа дают **одинаковый хеш** (или одинаковый индекс бакета).

```go
"Alice" → hash = 0x3A7 → индекс = 7
"Bob"   → hash = 0x1A7 → индекс = 7  // Коллизия!
```

**Коллизии** замедляют операции, но хорошая хеш-функция минимизирует их.

#### Какие способы по решению коллизий?

| Метод                                    | Описание                                                                    | Плюсы и минусы                         |
| ---------------------------------------- | --------------------------------------------------------------------------- | -------------------------------------- |
| **Chaining** (цепочки)                   | Переполненные ключи хранятся в связанных бакетах (как в Go).                | Простота, но возможны длинные цепочки. |
| **Open Addressing** (открытая адресация) | Ключи ищутся в других бакетах по алгоритму (линейный/квадратичный пробинг). | Лучше для кэша, но сложнее удаление.   |

##### Цепочки (Chaining)

Элементы с одинаковым хешом хранятся в виде связанного списка внутри бакета (как в Go).

```go
Бакет 1: ["Alice", 25] → ["Bob", 30]
```

##### Открытая адресация (Open Addressing)

При коллизии ищется следующий свободный бакет (например, линейный пробинг).

## Шаги работы Hash-мапы

1. **Вычисление хеша**:
	1. Ключ обрабатывается хэш-функцией, которая возвращает число (например, `hash("Alice") = 12345`).
2. **Определение бакета**:
	2. Индекс бакета вычисляется как `hash % количество_бакетов` (например, `12345 % 8 = 1` → бакет 1).
3. **Разрешение коллизий**:  
	1. Если в бакете уже есть элементы, используется метод **цепочки** (в Go) — элементы хранятся в виде связанного списка.
4. **Сохранение/поиск значения**:
	2. Ключ и значение сохраняются в бакете. При поиске ключ сравнивается с сохраненными ключами в бакете.

## Как устроена Map в Go?

- [Мапы в Go: уровень Pro](https://habr.com/ru/companies/avito/articles/774618/
- [Source code: old map](https://github.com/golang/go/blob/master/src/runtime/map_noswiss.go)
- [Source code: swiss map](https://github.com/golang/go/blob/master/src/runtime/map_swiss.go)
- Benchmarks 

**Мапа в Go** — это хеш-таблица с цепочками для разрешения коллизий и состоящая из:

- **`hmap`**: Основная структура с метаданными (количество элементов, бакеты и т.д.).    
- **`bmap` (бакеты)**: Каждый бакет хранит до 8 пар ключ-значение и ссылку на следующий бакет при коллизиях.

```go
// Заголовок для Go map.
type hmap struct {
    count     int        // Количество элементов
    B         uint8      // Логарифм числа бакетов (2^B)
    hash0     uint32     // hash seed    

    buckets   unsafe.Pointer // Указатель на массив 2^B бакетов, может быть nil, если count == 0.
	oldbuckets unsafe.Pointer // предыдущий массив бакетов половинного размера, не nil только тогда, когда было увеличение
	
// ... другие поля
}

type bmap struct {
    tophash  [8]uint8    // Первые 8 бит хешей ключей
    keys     [8]keyType  // Ключи
    values   [8]valueType// Значения
    overflow *bmap       // Ссылка на следующий бакет при коллизиях
}
```

### Схема
```go

-----------------------
| MAP                 |
|                     |
|   [LEN] [*Buckets]  |
|              |      |
---------------+-------
               |
               |
---------------+-----------
| Buckets                 |
|                         |
| [LOBHash]     [LOBHash] |
| [Bucket ]     [Bucket ] |
|    |                    |
-----+---------------------
     |
     |
-----+-------------------------
| [E1] ... [E5] [_] [_] [_]   |
|------------------------------
| [Key] [Key] [_] [Val] [Val] |
-------------------------------

```

### Асимптотика работы с мапой в Go

| Операция      | Средний случай | Худший случай (при коллизиях)          |
| ------------- | -------------- | -------------------------------------- |
| `map[key]`    | `O(1)`         | `O(n)` (если все ключи в одном бакете) |
| `map[key] =`  | `O(1)`         | `O(n)` (рехеширование)                 |
| `delete(key)` | `O(1)`         | `O(n)` (при рехешировании)             |

## Что такое Load-factor?

**Коэффициент заполняемости таблицы**, или **load factor** — это отношение количества хранимых пар «ключ-значение» к размеру таблицы. 

Формула:

```c
LF = количество_элементов / количество_бакетов
```

Если они достигают пограничного значения, то хэш-мапу расширяют, а индексы пар пересчитывают и перераспределяют.

- **По умолчанию в Go** мапа расширяется при `LF ≈ 6.5`.
- Высокий LF увеличивает вероятность коллизий.

## Как происходит реиндексация/рехеширование?

**Рехеширование** происходит при `Load Factor ≈ 6.5`.

При достижении `Load Factor` мапа в Go **расширяется в 2 раза**:

1. Создается новый массив бакетов (`len(newBuckets) = 2 * len(oldBuckets)`).    
2. Все ключи **перехешируются** и распределяются по новым бакетам.
3. Переход на новые бакеты происходит **постепенно** (при следующих операциях с мапой), чтобы избежать резких задержек.
    
**Совет**: Если известен размер мапы, инициализируйте её через `make(map[K]V, size)` для избежания лишних рехеширований.

### Псевдокод рехеширования

```go
func (h *hmap) grow() {
    newBuckets := make([]bmap, 2 * len(h.buckets))
    for bucket := range h.buckets {
        for key, val := range bucket {
            newHash := hash(key) % len(newBuckets)
            newBuckets[newHash].add(key, val)
        }
    }
    h.buckets = newBuckets
}
```

### Негативные кейсы

#### Что будет, если я буду писать/читать в/из nil Map?

| **Операция**        | **nil Map**                 |
| ------------------- | --------------------------- |
| **Запись**          | Паника (`panic`)            |
| **Чтение**          | Возвращает нулевое значение |
| **Проверка на nil** | `m == nil` → `true`         |
| **Использование**   | Только чтение (без паники)  |
Всегда инициализируйте мапы через `make()` или литерал:

```go
m := make(map[string]int) // или m := map[string]int{}
```

###### Запись в nil Map

Попытка записи в nil-мапу вызывает **панику** (panic):

```go
var m map[string]int
m["key"] = 42 // panic: assignment to entry in nil map
```

##### Чтение из nil Map

Чтение из nil-мапы **не вызывает паники** и возвращает нулевое значение типа:

```go
var m map[string]int
fmt.Println(m["key"]) // 0 (нулевое значение для int)
```

Для nil-мапы проверка через `, ok` всегда возвращает `false`:

```go
var m map[string]int
value, ok := m["key"]
fmt.Println(ok) // false
```

## Что может быть ключом в Map Go?

Все сравниваемые (comparable) типы данных:

- массивы
- TODO
- nil

Ключом не может быть:
- slice
- func

## Каков порядок перебора в Map в Go?

Случайный. Так как команда Golang 
TODO