# Про Go

## Плюсы в Go

**Основное:**

- Конкурентность. 
- Вытесняющая модель.

**Подробно:**

- **Простота и лаконичность** — язык минималистичен, легко читается, быстро учится.
- **Быстрая компиляция** — Go очень быстро компилируется, почти как скриптовый язык.
- **Встроенная поддержка конкурентности** — `goroutines`, `channels`, `select` позволяют просто писать многопоточные программы.
- **Отличный инструмент для backend и системного программирования**.
- **Статическая типизация** — помогает избежать многих ошибок на этапе компиляции.
- **Отличный набор стандартной библиотеки** — особенно для сетевого взаимодействия, JSON, HTTP и т.д.
- **Форматирование кода (`gofmt`)** — единый стиль кода "по умолчанию".
- **Бинарники без зависимостей** — удобно для деплоя (один файл — вся программа).

## Минусы GO

**Основное:**

- Каждый инстанс тащит за собой весь runtime Go (~ 5 mb).

**Подробно:**

- **Ограниченная система типов** — нет дженериков до Go 1.18, и даже с ними — они ограниченные.
- **Нет наследования и только интерфейсы** — хорошо, но иногда неудобно.
- **Нет перегрузки функций / операторов** — даже стандартные структуры не могут использовать `+`, `==` и т.д.
- **Бедная функциональная парадигма** — нет pattern matching, sum types и т.п.
- **Базовая ошибка обработки через `error`** — устаревшая и шумная.
- **Сложности с модульной системой (`go mod`)** — хотя стало лучше, но иногда баги/проблемы.

## Что огорчает в системе типов в Go?

- Отсутствие ковариантности и контравариантности:
	- когда нужно перекастить slice одних интерфейсов в другой slice интерфейсов.

- **Нет algebraic data types** (sum/product types, pattern matching).
- **Ограниченная полиморфность** — до Go 1.18 не было вообще, сейчас она есть, но без typeclasses, ADT и прочего.
- **Типизация интерфейсов не строгая** — часто runtime ошибки из-за неверного type assertion.
- **Нет явных readonly/const-модификаторов** — нельзя запретить модификацию структуры.

## Go императивный или декларативный?

**Go — однозначно императивный язык.**  

Он сосредоточен на пошаговых изменениях состояния, в стиле C. Декларативные конструкции практически отсутствуют (нет list comprehensions, pattern matching, monads, LINQ и прочего).

### В чём разница?

- Императивный - говоришь программе что сделать.
	- Go и т.д.
- Декларативный - говоришь программе как это сделать.
	- HTML, CSS и т.д.

## Какие средства обобщённого программирования в Go?

- Interface
- Generic
- Кодогенерация
- Рефлексия

# **Типы** в Go?

Типы определяют **форму и поведение** значений: как они хранятся, как с ними можно работать, какие операции над ними допустимы.

Есть 3 категории типов:
1. **Базовые** (встроенные): `int`, `float64`, `string`, `bool`, `rune`, `byte`, `complex64`, и т.д.
2. **Составные**: массивы, слайсы, мапы, структуры, функции, каналы.
3. **Пользовательские типы**: созданные через `type`, на основе других.

## Как создать **новый тип**

```go
type MyInt int
```

Теперь `MyInt` — **новый тип**, основанный на `int`. Он **не совместим напрямую** с `int`, и требует явного преобразования.

```go
var a MyInt = 5
var b int = int(a) // явное приведение
```

## Зачем создавать новые типы

### Больше читаемости

```go
type UserID int
type OrderID int
```

Даже если оба — `int`, их нельзя перепутать в коде или API.

### Добавление методов

```go
type Celsius float64

func (c Celsius) ToFahrenheit() float64 {
    return float64(c)*9/5 + 32
}
```

### Ограничение API

```go
// не примет обычный int случайно
func DoSomething(id UserID) { ... }
```

### Валидация/контроль

```go
type Email string

func (e Email) Validate() bool {
    return strings.Contains(string(e), "@")
}
```

## Необычные и интересные кейсы

### Методы на базовые типы

Мы можем "обогатить" встроенные типы своим поведением.

```go
type MyString string

func (s MyString) Shout() string {
	return strings.ToUpper(string(s))
}
```

### Типы как состояния (enum)

```go
type Status string

const (
	StatusPending  Status = "pending"
	StatusApproved Status = "approved"
	StatusRejected Status = "rejected"
)
```

И используешь безопасно:

```go
func Process(status Status) {
	switch status {
	case StatusPending:
		// ...
	default:
		// fail fast
	}
}
```

### Создание обёрток над внешними библиотеками

```go
type Logger struct {
	*zap.Logger // встраивание
}

func (l Logger) Info(msg string) {
	l.Logger.Info("[MyService] " + msg)
}
```

### Использование в обобщениях (generics)

С Go 1.18 появились дженерики, и теперь можно ограничивать типы:

```go
type MyNumber interface {
	~int | ~float64
}
```

## Важное отличие: **alias vs новый тип**

_Описание Alias приведено ниже._

```go
type A = B // alias (один и тот же тип)

type A B   // новый тип
```

Новый тип:

- нельзя использовать там, где ждут исходный,
- можно навешивать методы,
- полезен для типобезопасности.

# Alias

[Source code](https://github.com/golang/go/blob/master/src/go/types/alias.go#L46)

Alias — это **псевдоним типа или импорта**.

## Как alias устроен внутри

При компиляции `type A = B` просто **заменяется на B**, то есть в compiled code вообще нет `A`.

Это **удобно** для:
- миграции между типами    
- совместимости в старых API
- упрощения чтения

## Импорт alias

```go
import (
	json "encoding/json" // псевдоним для читаемости
	j "encoding/json"    // сокращение
)
```

## Тип alias

```go
type MyInt = int // alias (НЕ новый тип!)

var x MyInt = 5 // работает как обычный int
```

Такой alias **не создаёт нового типа**. Он буквально означает: "используй `MyInt` везде как `int`".

Для сравнения:

```go
type MyInt2 int // это НОВЫЙ тип
```

## Отличия alias vs новый тип

|Форма|Новый тип?|Совместим с исходным?|
|---|---|---|
|`type A = B`|❌|✅ полностью|
|`type A B`|✅|❌ нужно кастовать|

# Go директивы (`//go:`)

Go-директивы — это **специальные комментарии**, которые инструменты Go (`go`, `go vet`, `go generate`, `cgo`, и т.д.) используют как **инструкции**.

## //go:generate

Это **указание компилятору или IDE** на команду, которую надо запустить при `go generate`.

Команда `go generate` запускает эту строку как shell-команду.

Используется для генерации кода: `stringer`, `mockgen`, `protoc`, `swag`, и т.д.

```go
//go:generate stringer -type=Color
type Color int

const (
	Red Color = iota
	Green
	Blue
)
```

## Другие

| Директива         | Назначение                                        |
| ----------------- | ------------------------------------------------- |
| `//go:embed`      | Встраивание файлов в бинарник (начиная с Go 1.16) |
| `//go:noinline`   | Запрещает инлайнинг функции                       |
| `//go:nosplit`    | Запрещает вставку проверки на stack overflow      |
| `//go:linkname`   | Доступ к приватным символам в другом пакете       |
| `//go:build`      | Условия сборки (вместо старых `+build`)           |
| `//go:wasmimport` | Указание импорта из WebAssembly                   |
| `//go:unsafe`     | Используется при работе с `unsafe` пакетом        |

# Что такое defer

Это отложенный вызов, будет вызван в моменте выхода из контекста текущей функции. Будет завершаться в порядке FILO. Будет выполнен до возврата результата (до return).

### Зачем нужен?

- Помогает (_не забыть_) закрыть соединения/открытые файлы перед завершением функции.
- Он помогает обработать ситуации с **panic**, через функцию `recover()`.

- Для **закрытия ресурсов**: `defer file.Close()` 
- Для **логирования** выхода из функции
- Для **отката** состояния
- Для **паники / recover**

### Как работает изнутри

- `defer` сохраняет информацию о вызове (аргументы копируются) в стек `defer`-ов.
- При выходе из функции (нормально или через `panic`), стек обходится в **обратном порядке** (LIFO).
- `defer` добавляет накладные расходы — на каждый defer создаётся небольшой объект.

```go
func main() {
    for i := 0; i < 3; i++ {
        defer fmt.Println(i)
    }
}
// Вывод: 2 1 0
```

# Что такое sum types

**Sum types (суммарные типы)** — это типы, которые могут принимать одно из нескольких значений. Пример из других языков:

```rust
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}
```

### Как реализовать в Go

В Go можно "приблизить" sum types через интерфейсы:

```go
type Shape interface {
    Area() float64
}

type Circle struct {
    Radius float64
}
func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius }

type Rectangle struct {
    Width, Height float64
}
func (r Rectangle) Area() float64 { return r.Width * r.Height }

// Использование:
func PrintArea(s Shape) {
    fmt.Println(s.Area())
}

```

Но **настоящих sum types (как в Haskell или Rust)** в Go нет. Это вызывает проблему "type-safe disjunction".

# Есть ли в Go деструкторы?

**Можно сказать, что - нет**. Максимум, чем мы пользуемся на практике - это `defer`. 
Но, мало кто знает, что в Go есть **финалайзеры (`finalizer`)**, но на практике (*почти*) никто ими не пользуется.

`finalizer` - используется в GC перед очисткой (когда все ссылки пропали на объект через finalizer).
Также можем сами реализовать finalizer у структуры, через `runtime.SetFinalizer`, [пример1](https://gist.github.com/deltamobile/6511901):

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

type Foo struct {
	name string
	num  int
}

func finalizer(f *Foo) {
	fmt.Println("a finalizer has run for ", f.name, f.num)
}

var counter int

func MakeFoo(name string) (a_foo *Foo) {
	a_foo = &Foo{name, counter}
	counter++
	runtime.SetFinalizer(a_foo, finalizer)
	return
}

func Bar() {
	f1 := MakeFoo("one")
	f2 := MakeFoo("two")

	fmt.Println("f1 is: ", f1.name)
	fmt.Println("f2 is: ", f2.name)
}

func main() {
	for i := 0; i < 3; i++ {
		Bar()
		time.Sleep(time.Second)
		runtime.GC()
	}
	fmt.Println("done.")
}

```

# Как взаимодействуют Garbage collector и Scheduler

- **GC нужен scheduler'у**, чтобы "остановить мир" на короткое время, когда нужно безопасно собрать мусор.
- **Scheduler сообщает GC**, какие goroutine сейчас активны, где у них стеки и локальные переменные.
- GC **может временно остановить goroutine**, чтобы просканировать их stack (корни графа ссылок).

При этом GC работает **параллельно** с кодом — чтобы минимизировать паузы.

|Сущность|Отвечает за|Примеры работы|
|---|---|---|
|**GC**|Очистка памяти|Удаляет неиспользуемые объекты из heap|
|**Scheduler**|Управление исполнением goroutine|Планирует, запускает, паркует, переключает|
|**Общее**|Взаимодействуют через stack/heap|GC может приостановить goroutine для сканирования|
