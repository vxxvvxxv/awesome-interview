# Про Go

## Плюсы в Go

**Основное:**

- Конкурентность. 
- Вытесняющая модель.

**Подробно:**

- **Простота и лаконичность** — язык минималистичен, легко читается, быстро учится.
- **Быстрая компиляция** — Go очень быстро компилируется, почти как скриптовый язык.
- **Встроенная поддержка конкурентности** — `goroutines`, `channels`, `select` позволяют просто писать многопоточные программы.
- **Отличный инструмент для backend и системного программирования**.
- **Статическая типизация** — помогает избежать многих ошибок на этапе компиляции.
- **Отличный набор стандартной библиотеки** — особенно для сетевого взаимодействия, JSON, HTTP и т.д.
- **Форматирование кода (`gofmt`)** — единый стиль кода "по умолчанию".
- **Бинарники без зависимостей** — удобно для деплоя (один файл — вся программа).

## Минусы GO

**Основное:**

- Каждый инстанс тащит за собой весь runtime Go (~ 5 mb).

**Подробно:**

- **Ограниченная система типов** — нет дженериков до Go 1.18, и даже с ними — они ограниченные.
- **Нет наследования и только интерфейсы** — хорошо, но иногда неудобно.
- **Нет перегрузки функций / операторов** — даже стандартные структуры не могут использовать `+`, `==` и т.д.
- **Бедная функциональная парадигма** — нет pattern matching, sum types и т.п.
- **Базовая ошибка обработки через `error`** — устаревшая и шумная.
- **Сложности с модульной системой (`go mod`)** — хотя стало лучше, но иногда баги/проблемы.

## Что огорчает в системе типов в Go?

- Отсутствие ковариантности и контравариантности:
	- когда нужно перекастить slice одних интерфейсов в другой slice интерфейсов.

- **Нет algebraic data types** (sum/product types, pattern matching).
- **Ограниченная полиморфность** — до Go 1.18 не было вообще, сейчас она есть, но без typeclasses, ADT и прочего.
- **Типизация интерфейсов не строгая** — часто runtime ошибки из-за неверного type assertion.
- **Нет явных readonly/const-модификаторов** — нельзя запретить модификацию структуры.

## Go императивный или декларативный?

**Go — однозначно императивный язык.**  

Он сосредоточен на пошаговых изменениях состояния, в стиле C. Декларативные конструкции практически отсутствуют (нет list comprehensions, pattern matching, monads, LINQ и прочего).

### В чём разница?

- Императивный - говоришь программе что сделать.
	- Go и т.д.
- Декларативный - говоришь программе как это сделать.
	- HTML, CSS и т.д.

## Какие средства обобщённого программирования в Go?

- Interface
- Generic
- Кодогенерация
- Рефлексия

## Что такое sum types?

**Sum types (суммарные типы)** — это типы, которые могут принимать одно из нескольких значений. Пример из других языков:

```rust
enum Shape {
    Circle(f64),
    Rectangle(f64, f64),
}
```

### Как реализовать в Go?

В Go можно "приблизить" sum types через интерфейсы:

```go
type Shape interface {
    Area() float64
}

type Circle struct {
    Radius float64
}
func (c Circle) Area() float64 { return math.Pi * c.Radius * c.Radius }

type Rectangle struct {
    Width, Height float64
}
func (r Rectangle) Area() float64 { return r.Width * r.Height }

// Использование:
func PrintArea(s Shape) {
    fmt.Println(s.Area())
}

```

Но **настоящих sum types (как в Haskell или Rust)** в Go нет. Это вызывает проблему "type-safe disjunction".

## Что такое defer

Это отложенный вызов, будет вызван в моменте выхода из контекста текущей функции. Будет завершаться в порядке FILO. Будет выполнен до возврата результата (до return).

### Зачем нужен?

- Помогает (_не забыть_) закрыть соединения/открытые файлы перед завершением функции.
- Он помогает обработать ситуации с **panic**, через функцию `recover()`.

- Для **закрытия ресурсов**: `defer file.Close()` 
- Для **логирования** выхода из функции
- Для **отката** состояния
- Для **паники / recover**

### Как работает изнутри

- `defer` сохраняет информацию о вызове (аргументы копируются) в стек `defer`-ов.
- При выходе из функции (нормально или через `panic`), стек обходится в **обратном порядке** (LIFO).
- `defer` добавляет накладные расходы — на каждый defer создаётся небольшой объект.

```go
func main() {
    for i := 0; i < 3; i++ {
        defer fmt.Println(i)
    }
}
// Вывод: 2 1 0
```

## Есть ли в Go деструкторы?

**Можно сказать, что - нет**. Максимум, чем мы пользуемся на практике - это `defer`. 
Но, мало кто знает, что в Go есть **финалайзеры (`finalizer`)**, но на практике (*почти*) никто ими не пользуется.

`finalizer` - используется в GC перед очисткой (когда все ссылки пропали на объект через finalizer).
Также можем сами реализовать finalizer у структуры, через `runtime.SetFinalizer`, [пример1](https://gist.github.com/deltamobile/6511901):

```go
package main

import (
	"fmt"
	"runtime"
	"time"
)

type Foo struct {
	name string
	num  int
}

func finalizer(f *Foo) {
	fmt.Println("a finalizer has run for ", f.name, f.num)
}

var counter int

func MakeFoo(name string) (a_foo *Foo) {
	a_foo = &Foo{name, counter}
	counter++
	runtime.SetFinalizer(a_foo, finalizer)
	return
}

func Bar() {
	f1 := MakeFoo("one")
	f2 := MakeFoo("two")

	fmt.Println("f1 is: ", f1.name)
	fmt.Println("f2 is: ", f2.name)
}

func main() {
	for i := 0; i < 3; i++ {
		Bar()
		time.Sleep(time.Second)
		runtime.GC()
	}
	fmt.Println("done.")
}

```

# Как взаимодействуют Garbage collector и Scheduler

- **GC нужен scheduler'у**, чтобы "остановить мир" на короткое время, когда нужно безопасно собрать мусор.
- **Scheduler сообщает GC**, какие goroutine сейчас активны, где у них стеки и локальные переменные.
- GC **может временно остановить goroutine**, чтобы просканировать их stack (корни графа ссылок).

При этом GC работает **параллельно** с кодом — чтобы минимизировать паузы.

|Сущность|Отвечает за|Примеры работы|
|---|---|---|
|**GC**|Очистка памяти|Удаляет неиспользуемые объекты из heap|
|**Scheduler**|Управление исполнением goroutine|Планирует, запускает, паркует, переключает|
|**Общее**|Взаимодействуют через stack/heap|GC может приостановить goroutine для сканирования|
