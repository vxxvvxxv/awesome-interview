
Generics в Go долго были "священным граалем", и наконец появились в Go 1.18.

### Что это?

**Generics** (или **обобщения**) — это возможность писать **обобщённый код**, который работает с разными типами **без дублирования** и **без использования `interface{}`**.

Пример:

```go
func PrintAll[T any](items []T) {
    for _, item := range items {
        fmt.Println(item)
    }
}
```

Здесь `T` — **параметр типа**. Это функция, которая может принимать `[]int`, `[]string`, `[]MyStruct` и т.д.

### Для чего были созданы generics в Go?

- **Избежать дублирования кода** для разных типов (особенно коллекции, алгоритмы, утилиты).
- **Улучшить типобезопасность** вместо `interface{}` (нет type assertion).
- **Улучшить производительность** (нет лишнего boxing/unboxing).
- **Расширить выразительность языка**, сохранив при этом простоту.

### Что позволяют сделать?

- Написать **обобщённые функции и типы**, работающие с любыми совместимыми типами.
- Использовать **ограничения типов** (`type constraints`) через интерфейсы:
```go
type Adder[T any] interface {
    Add(T) T
}
```

- Создавать обобщённые структуры:
```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(v T)   { s.items = append(s.items, v) }
func (s *Stack[T]) Pop() T     { ... }
```

- Строить **реиспользуемые алгоритмы**: сортировка, фильтрация, агрегация и т.д.

### Как делали до generics

Вот как делали раньше:

```go
func MapStrings(items []string, f func(string) string) []string
func MapInts(items []int, f func(int) int) []int
```

Теперь:

```go
func Map[T any](items []T, f func(T) T) []T
```

### Когда стоит использовать

Используй generics, когда:

- Нужно **написать повторяющийся код** для разных типов, и они имеют схожее поведение.
- Нужно написать **библиотеку / утилиту** (например, контейнеры, алгоритмы, сравнения).
- Нужно сохранить **типобезопасность** (вместо `interface{}`).
- Нужно написать **вспомогательные функции** (например, `Map`, `Filter`, `Reduce`).

### Когда не стоит использовать

- **Преждевременно**: если нет нужды в типовой обобщённости — лучше не усложнять.
- Если достаточно **интерфейсов**, то иногда они проще и читаемее.
- Для логики, специфичной под конкретный тип.
- Если generics ухудшают читаемость и не дают явной пользы.

### Полезные встроенные constraints

В пакете `golang.org/x/exp/constraints`:

- `constraints.Ordered`: типы, поддерживающие `<`, `>`, `==`.
- `constraints.Integer`: любые целые.
- `constraints.Float`: `float32`, `float64`.

