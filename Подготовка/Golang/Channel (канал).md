Полезные ссылки:
- [Source code](https://github.com/golang/go/blob/master/src/runtime/chan.go).
- [Как на самом деле устроены каналы в Golang? | Golang channels internals](https://www.youtube.com/watch?v=ZTJcaP4G4JM)

---

## Как устроены?

Каналы (channels) в Go — это механизм **безопасной передачи данных между горутинами**, основанный на модели **CSP (Communicating Sequential Processes)**. Они обеспечивают синхронизацию и предотвращают race conditions без явных блокировок.

### Модель CSP (Communicating Sequential Processes)

**CSP** — это формальная модель параллельных вычислений, предложенная Тони Хоаром в 1978 году. В Go она реализована через каналы и горутины.

**CSP** в Go — это общение через каналы без shared memory.

#### Основные принципы CSP

- **Горутины** (легковесные потоки) взаимодействуют **только через обмен сообщениями** (каналы), а не через общую память.
- **Нет явных блокировок** (мьютексов) — синхронизация происходит автоматически при отправке/получении данных.
- **Каналы** — это **точки рандеву**: отправитель и получатель должны встретиться для обмена данными (если канал небуферизированный).

##### Пример CSP в Go

Здесь `producer` и `consumer` работают независимо, но синхронизируются через канал `ch`.

```go
// Горутина-производитель
producer := func(ch chan int) {
    for i := 0; i < 3; i++ {
        ch <- i  // Отправка данных
    }
    close(ch)
}

// Горутина-потребитель
consumer := func(ch chan int) {
    for v := range ch {
        fmt.Println(v)  // Получение данных
    }
}

ch := make(chan int)
go producer(ch)
consumer(ch)

// Output:
// 0
// 1
// 2
```


### Основные свойства каналов

- **Типизированные**: `chan int`, `chan string` и т.д.
- **Могут быть:**
	- **буферизированными** (`make(chan int, 5)`),
	- **небуферизированными** (`make(chan int)`).
- **Операции отправки** (`ch <- v`) и **получения** (`<-ch`) **блокируют горутины**, если канал заполнен или пуст.
- **Закрытие канала** (`close(ch)`) сигнализирует о завершении работы.

### Важные замечания

[Источник](https://go.dev/tour/concurrency/4).

- Только отправитель должен закрыть канал, а не получатель. Отправка по закрытому каналу вызовет панику.
- **Каналы не похожи на файлы**; обычно не нужно их закрывать. Закрытие необходимо только тогда, когда приемнику нужно сообщить, что больше нет значений, например, завершить цикл `range`.

### 4 аксиомы каналов

[Подробнее](https://dave.cheney.net/2014/03/19/channel-axioms)

1. При **записи в закрытый** канал будет **panic**.
	1. Канал должен закрывать всегда - писатель.
2. При **чтении с закрытого** канала мы получаем **“нулевое” значение** соотвествующего типа.
	2. Если нужно, можем получить flag о закрытости/открытости канала (вторым аргументом).
3. При **чтении** из **не инициализированного** канала (нет make) - будет **deadlock**.
4. При **записи** в **не инициализированного** канала (нет make) - будет **deadlock**.

### Внутренняя реализация каналов

[Исходный код](https://github.com/golang/go/blob/master/src/runtime/chan.go)

Каналы в Go реализованы как **кольцевой буфер (циклическая очередь)** + **мьютекс** для синхронизации. Их структура в исходном коде (`runtime/chan.go`):

```go
type hchan struct {
    qcount   uint           // Количество элементов в буфере
    dataqsiz uint           // Размер буфера
    buf      unsafe.Pointer // Указатель на (массив элементов dataqsiz) буфер (кольцевой)
    elemsize uint16         // Размер элемента
	synctest bool           // true, если создано в synctest пузыре
    closed   uint32         // Флаг закрытия
    timer    *timer         // таймер, питающий этот chan
    elemtype *_type         // Тип элемента
    sendx    uint           // Индекс отправки (в буфере)
    recvx    uint           // Индекс получения (в буфере)
    recvq    waitq          // Очередь ожидающих получателей (горутин)
    sendq    waitq          // Очередь ожидающих отправителей (горутин)

// lock защищает все поля в hchan, а также несколько
// полей в судогах, заблокированных на этом канале.
//
// Не изменяйте статус другого G, удерживая эту блокировку
// (в частности, не готовы G), так как это может взаимоблокировка
// со сжатием стека.
    lock     mutex          // Мьютекс для синхронизации
}
```

#### Схема

```go

-----------------------------------------
| channel                               |
|                                       |
|         [sendx] [recvx] [*buf] [lock] |
|             |      |      |           |
--------------+------+------+------------
              |      |      |
              |      |      |
              |      |      |
              |      |      |
--------------+------+-------------------
| Buffer      |      |                  |
|             |      |                  |
|            _|_    _|_    ___    ___   |
| Index:    | 0 |  | 1 |  | 2 |  | 3 |  |
|           |---|  |---|  |---|  |---|  |
|           |   |  |   |  |   |  |   |  |
| Values:   |Val|  |   |  |   |  |   |  |
|           |___|  |___|  |___|  |___|  |
----------------------------------------|

```

#### Ключевые компоненты:

1. **Буфер** (`buf`)
	1. Хранит элементы канала.
	2. Если канал **небуферизированный** (`make(chan int)`), `buf` не используется — данные передаются напрямую между горутинами (вставка в stack горутины).
2. **Очереди ожидания** (`recvq`, `sendq`)
    - Если канал **полон** (отправитель не может записать) или **пуст** (получатель не может прочитать), горутина блокируется и попадает в соответствующую очередь (`waitq`).
3. **Мьютекс** (`lock`)
	1. Защищает доступ к структуре `hchan` при конкурентных операциях.

#### Как работают операции с каналами?

##### Отправка (`ch <- v`)

###### Буферизированный канал:

- Если есть место в буфере, значение копируется в `buf[sendx]`, `sendx` увеличивается.
- Если буфер полон, горутина блокируется и попадает в `sendq`.

###### Небуферизированный канал:

- Если есть ожидающий получатель (`recvq`), значение передается напрямую ему.
- Если получателей нет, горутина блокируется.

##### Получение (`<-ch`)

###### Буферизированный канал:

- Если в буфере есть данные, возвращается `buf[recvx]`, `recvx` увеличивается.
- Если буфер пуст, горутина блокируется и попадает в `recvq`.

###### Небуферизированный канал:

- Если есть ожидающий отправитель (`sendq`), значение берется напрямую из него.
- Если отправителей нет, горутина блокируется.

##### Закрытие (`close(ch)`)

- Устанавливает флаг `closed = 1`.
- Разблокирует все горутины из `recvq` (они получат нулевое значение).
- Попытка **отправить в закрытый** канал вызывает **panic**.
- Попытка **закрыть закрытый** канал вызывает **panic**.

#### Примеры

##### Небуферизированный канал (синхронный обмен)

```go
ch := make(chan int)
go func() {
    ch <- 42  // Блокируется, пока main() не прочитает
}()
fmt.Println(<-ch) // 42
```

##### Буферизированный канал (асинхронный)

```go
ch := make(chan int, 2)
ch <- 1  // Не блокируется (место есть)
ch <- 2  // Не блокируется
// ch <- 3  // Блокируется (буфер полон)
fmt.Println(<-ch) // 1
```

##### Закрытие канала

```go
ch := make(chan int, 1)
ch <- 42
close(ch)
val, ok := <-ch
fmt.Println(val, ok) // 42, true (значение получено)
val, ok = <-ch
fmt.Println(val, ok) // 0, false (канал закрыт)
```

##### Специальные случаи

###### Select: мультиплексирование каналов

```go
select {
case v := <-ch1:
    fmt.Println("Получено из ch1:", v)
case ch2 <- 42:
    fmt.Println("Отправлено в ch2")
default:
    fmt.Println("Ничего не готово")
}
```

###### Deadlock - Нет получателя

```go
ch := make(chan int)
ch <- 42  // Блокируется навсегда (нет получателя)
fmt.Println(<-ch)

// PANIC
// fatal error: all goroutines are asleep - deadlock!
```

###### Deadlock - Нет писателя

```go
ch := make(chan int)

// Блокируется навсегда (нет писателя)
fmt.Println(<-ch) 

// PANIC
// fatal error: all goroutines are asleep - deadlock!
```


###### Deadlock - Не инициализирован канал

```go
var ch chan int

for i := 0; i < 3; i++ {
	go func(num int) {
		ch <- num
	}(i)
}

for i := 0; i < 3; i++ {
	fmt.Println(<-ch)
}

fmt.Println("finish")

// PANIC
// fatal error: all goroutines are asleep - deadlock!
```

### Производительность и рекомендации

- **Небуферизированные** каналы быстрее для синхронного обмена.
- Буферизированные полезны для ограничения скорости (*rate limiting*) и асинхронных задач.
- Закрывайте каналы, чтобы избежать утечек горутин.
- Используйте `select` с `default` для неблокирующих операций.

## Кольцевой буфер в каналах Go

Кольцевой буфер (циклическая очередь) — это структура данных, используемая в **буферизированных каналах** (`make(chan int, 5)`).

**Кольцевой буфер в Go** — основа буферизированных каналов с индексами `sendx`/`recvx`.

### Как устроен

- **Фиксированный размер**: задаётся при создании (`make(chan int, N)`).
- **Два указателя**:
	- `sendx` — индекс для записи.
	- `recvx` — индекс для чтения.
- **При переполнении индексы "заворачиваются"** на начало буфера (отсюда название "кольцевой").

#### Пример работы буфера

```go
ch := make(chan int, 3)  // Буфер: [_, _, _]
ch <- 1                  // Буфер: [1, _, _], sendx = 1
ch <- 2                  // Буфер: [1, 2, _], sendx = 2
ch <- 3                  // Буфер: [1, 2, 3], sendx = 0 (переход на начало)
<-ch                     // Читаем 1, recvx = 1
ch <- 4                  // Буфер: [4, 2, 3], sendx = 1
```

### Очереди в каналах (`recvq` и `sendq`)

- Блокируют горутины при переполнении/опустошении.    
- Разблокируют при появлении места/данных.

Когда канал **полон** или **пуст**, горутины попадают в одну из очередей:

| Очередь     | Описание                                                           |
| ----------- | ------------------------------------------------------------------ |
| **`sendq`** | Очередь горутин, ожидающих отправки данных (если канал **полон**). |
| **`recvq`** | Очередь горутин, ожидающих получения данных (если канал **пуст**). |

#### Как работают

1. **Буферизированный канал полон** → Отправитель (`ch <- v`) попадает в `sendq`.
2. **Буферизированный канал пуст** → Получатель (`<-ch`) попадает в `recvq`.
3. **Небуферизированный канал**:
	1. Если нет получателя, отправитель попадает в `sendq`.
	2. Если нет отправителя, получатель попадает в `recvq`.

##### Пример блокировки и разблокировки

```go
ch := make(chan int, 1)  // Буфер размера 1
ch <- 1                  // Буфер заполнен

// Горутина 1: пытается отправить (блокируется в sendq)
go func() {
    ch <- 2
    fmt.Println("Отправлено 2")
}()

// Горутина 2: читает и разблокирует Горутину 1
go func() {
    time.Sleep(1 * time.Second)
    <-ch                  // Читает 1, освобождает буфер
    fmt.Println("Прочитано 1")
}()
time.Sleep(2 * time.Second)

// Output:
// Прочитано 1
// Отправлено 2
```

### Роль очередей в кольцевом буфере

1. **Синхронизация**:
	1. Очереди `sendq` и `recvq` позволяют горутинам **ждать**, не занимая CPU.
2. **Прямая передача данных**:
	1. Если горутина в `sendq` пытается отправить, а появляется получатель (или наоборот), данные передаются **напрямую**, минуя буфер (для небуферизированных каналов).
3. **Эффективное использование памяти**:
	1. Вместо создания новых структур для каждого ожидающего, горутины складываются в очередь.

### Взаимодействие буфера и очередей

**Буфер + очереди** обеспечивают баланс между скоростью и синхронизацией.

- **Когда в буфере есть место**:
	- Отправитель (`ch <- v`) пишет в `buf[sendx]`.
	- Если в `recvq` есть ждущие, данные сразу передаются им.
- **Когда буфер пуст**:
	- Получатель (`<-ch`) читает из `buf[recvx]`.
	- Если в `sendq` есть ждущие, их данные сразу помещаются в буфер.

## В чем разница буферизированного от не буферизированного?

**Буферизированные каналы** — для асинхронности, **небуферизированные** — для синхронного обмена.

|Характеристика|Небуферизированный канал (`make(chan T)`)|Буферизированный канал (`make(chan T, N)`)|
|---|---|---|
|**Размер буфера**|0 (нет буфера)|`N` (заданный размер)|
|**Отправка (`ch <- v`)**|Блокируется, пока другая горутина не прочитает|Блокируется **только если буфер полон**|
|**Получение (`<-ch`)**|Блокируется, пока другая горутина не отправит|Блокируется **только если буфер пуст**|
|**Синхронизация**|Полная (рандеву-обмен)|Частичная (асинхронная отправка/получение)|
|**Использование**|Для строгой синхронизации горутин|Для асинхронной обработки и rate limiting|

### Пример

```go
// Небуферизированный канал (синхронный)
ch1 := make(chan int)
go func() { ch1 <- 42 }()  // Блокируется до чтения
fmt.Println(<-ch1)         // 42

// Буферизированный канал (асинхронный)
ch2 := make(chan int, 2)
ch2 <- 1  // Не блокируется
ch2 <- 2  // Не блокируется
fmt.Println(<-ch2, <-ch2)  // 1, 2
```

## Паттерны использования каналов?

**Паттерны**: Worker Pool, Graceful Shutdown, Rate Limiting.

### Worker Pool (Пул горутин)

#### Для чего создан?

**Worker Pool** — это паттерн, который позволяет:
- **Ограничить число одновременно работающих горутин** (чтобы не перегружать систему).
- **Эффективно распределять задачи** между фиксированным набором "воркеров".
- **Снижать накладные расходы** на создание/уничтожение горутин (переиспользование).

#### Где применяется?

- Обработка большого количества задач (например, запросов к API).
- Парсинг данных из множества файлов.
- Параллельные вычисления (например, рендеринг кадров).

#### Как работает?

- Создается пул горутин (воркеров), которые ждут задачи.
- Задачи отправляются в общий канал (jobs).
- Воркеры читают задачи из канала, обрабатывают и пишут результаты в другой канал (results).

#### Примеры

##### Worker Pool на 3 горутины

###### Что происходит?

- Одновременно работают только **3 воркера** (остальные задачи ждут в очереди).
- Результаты возвращаются по мере выполнения.

```go
package main

import (
	"fmt"
	"time"
)

func worker(id int, jobs <-chan int, results chan<- int) {
	for j := range jobs {
		fmt.Printf("Воркер %d начал задачу %d\n", id, j)
		time.Sleep(1 * time.Second) // Имитация работы
		results <- j * 2
		fmt.Printf("Воркер %d завершил задачу %d\n", id, j)
	}
}

func main() {
	const numJobs = 5
	jobs := make(chan int, numJobs)
	results := make(chan int, numJobs)

	// Запускаем 3 воркера
	for w := 1; w <= 3; w++ {
		go worker(w, jobs, results)
	}

	// Отправляем задачи
	for j := 1; j <= numJobs; j++ {
		jobs <- j
	}
	close(jobs)

	// Получаем результаты
	for r := 1; r <= numJobs; r++ {
		fmt.Println("Результат:", <-results)
	}
}

// Output:
// Воркер 1 начал задачу 1
// Воркер 2 начал задачу 2
// Воркер 3 начал задачу 3
// Воркер 1 завершил задачу 1
// Результат: 2
// Воркер 1 начал задачу 4
// Воркер 2 завершил задачу 2
// Результат: 4
// Воркер 2 начал задачу 5
// Воркер 3 завершил задачу 3
// Результат: 6
// Воркер 1 завершил задачу 4
// Результат: 8
// Воркер 2 завершил задачу 5
// Результат: 10
```

### Graceful Shutdown (Остановка горутин через канал)

```go
done := make(chan bool)
go func() {
    for {
        select {
        case <-done:
            return
        default:
            fmt.Println("Работаю...")
            time.Sleep(1 * time.Second)
        }
    }
}()

time.Sleep(3 * time.Second)
done <- true  // Сигнал остановки
```

### Rate Limiting (Ограничение скорости)

#### Для чего создан?

Rate Limiting - это паттерн, который позволяет:
- **Контролировать частоту выполнения операций** (например, запросов к API).
- **Защищать сервисы от перегрузки** (DDoS, слишком частые запросы).
- **Балансировать нагрузку** между системами.

#### Где применяется?

- Ограничение API-запросов (например, не более 100 RPS).
- Плавный вывод данных (логирование, мониторинг).
- Очереди сообщений (Kafka, RabbitMQ).

#### Примеры

##### Фиксированный интервал (`time.Tick`)

Каждый новый запрос ждет следующего "тика" лимитера.

```go
func main() {
	requests := make(chan int, 5)
	for i := 1; i <= 5; i++ {
		requests <- i
	}
	close(requests)

	// Ограничение: 1 запрос в 200 мс
	limiter := time.Tick(200 * time.Millisecond)

	for req := range requests {
		<-limiter // Блокировка до следующего "тика"
		fmt.Println("Обработка запроса", req, time.Now())
	}
}

// Output:
// Обработка запроса 1 2009-11-10 23:00:00.2 +0000 UTC m=+0.200000001
// Обработка запроса 2 2009-11-10 23:00:00.4 +0000 UTC m=+0.400000001
// Обработка запроса 3 2009-11-10 23:00:00.6 +0000 UTC m=+0.600000001
// Обработка запроса 4 2009-11-10 23:00:00.8 +0000 UTC m=+0.800000001
// Обработка запроса 5 2009-11-10 23:00:01 +0000 UTC m=+1.000000001
```

##### Token Bucket (Гибкое ограничение)

- Первые 3 запроса выполняются сразу (есть токены).
- Остальные — с интервалом 200 мс.

```go
func main() {
	burstyLimiter := make(chan time.Time, 3) // Буфер на 3 "токена"
	defer close(burstyLimiter)

	// Заполняем буфер (разрешаем 3 мгновенных запроса)
	for i := 0; i < 3; i++ {
		burstyLimiter <- time.Now()
	}

	// Новый токен каждые 200 мс
	go func() {
		for t := range time.Tick(200 * time.Millisecond) {
			burstyLimiter <- t
		}
	}()

	// Имитация запросов
	requests := make(chan int, 5)
	for i := 1; i <= 5; i++ {
		requests <- i
	}
	close(requests)

	for req := range requests {
		<-burstyLimiter // Блокировка, если нет токенов
		fmt.Println("Обработка", req, time.Now())
	}
}

// Output:
// Обработка 1 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 # Мгновенно (токен был)
// Обработка 2 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 # Мгновенно
// Обработка 3 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 # Мгновенно
// Обработка 4 2009-11-10 23:00:00.2 +0000 UTC m=+0.200000001 # После задержки
// Обработка 5 2009-11-10 23:00:00.4 +0000 UTC m=+0.400000001 # После задержки
```

### Что такое pipe (конвейер)?

**Pipe** — цепочка каналов для последовательной обработки.

**Pipe** — это цепочка каналов, где выход одного канала является входом для другого.  
Используется для **последовательной обработки данных** (отправка/принятие файлов и т.д.).

#### Примеры

##### Конвейер для чисел

```go
// Генератор чисел
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}

// Умножение чисел
func sq(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}

// Вывод
for n := range sq(gen(1, 2, 3)) {
    fmt.Println(n)  // 1, 4, 9
}
```

### Что такое Fanin и Fanout?

- **Fan-Out** — распределение задач, **Fan-In** — объединение результатов.

#### Fan-Out (Разветвление)

Один канал распределяет задачи между **несколькими горутинами** для параллельной обработки.

```go
func worker(id int, jobs <-chan int) {
    for j := range jobs {
        fmt.Printf("Воркер %d: %d\n", id, j)
    }
}

jobs := make(chan int, 10)

// Запуск 3 воркеров (Fan-Out)
for w := 1; w <= 3; w++ {
    go worker(w, jobs)
}

// Отправка задач
for j := 1; j <= 5; j++ {
    jobs <- j
}
close(jobs)
```

#### Fan-In (Слияние)

Несколько каналов объединяются в **один** для агрегации результатов.

```go
func merge(chs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    // Запуск горутин для каждого канала
    for _, ch := range chs {
        wg.Add(1)
        go func(c <-chan int) {
            for n := range c {
                out <- n
            }
            wg.Done()
        }(ch)
    }

    // Закрытие out после завершения всех горутин
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}

// Использование
ch1 := gen(1, 2, 3)
ch2 := gen(4, 5, 6)
for n := range merge(ch1, ch2) {
    fmt.Println(n)  // 1, 4, 2, 5, 3, 6 (порядок не гарантирован)
}
```

## Невалидные операции с каналами?

В Go каналы имеют строгие правила использования. Нарушение этих правил приводит к **панике** (panic) или **блокировке** горутин. 

| Операция                         | Результат                        |
| -------------------------------- | -------------------------------- |
| **Двойное закрытие**             | `panic: close of closed channel` |
| **Отправка (запись) в закрытый** | `panic: send on closed channel`  |
| **Чтение из закрытого**          | Возвращает `zero value, false`   |
| **Чтение из nil-канала**         | Deadlock                         |
| **Закрытие nil-канала**          | `panic: close of nil channel`    |

**Правила работы с каналами:**
1. **Закрывайте канал только отправителем** (не получателем).
2. **Не закрывайте канал дважды**.
3. **Не отправляйте в закрытый канал**.
4. **Инициализируйте каналы перед использованием**.

### Двойное закрытие канала (`close(ch)`)

При повторном закрытии канала возникает **паника** (panic).

```go
ch := make(chan int)
close(ch)
close(ch) // Паника!
```

### Отправка (запись) в закрытый канал (`ch <- data`)

Попытка отправить данные в закрытый канал вызывает **панику**.

 Это нештатная ситуация, так как писатель должен закрывать канал и после повторной попытки отправить в закрытый канал - это приводит к аварийному завершению программы.

```go
ch := make(chan int)
close(ch)
ch <- 42 // Паника!
```

### Чтение из закрытого канала (`<-ch`)

- Если канал **закрыт и пуст**, операция `<-ch` возвращает **нулевое значение типа** (например, `0` для `int`, `nil` для указателей).
- Второе возвращаемое значение (`ok`) будет `false`.

```go
ch := make(chan int, 2)
ch <- 1
ch <- 2
close(ch)

val, ok := <-ch
fmt.Println(val, ok) // 1, true

val, ok = <-ch
fmt.Println(val, ok) // 2, true

val, ok = <-ch
fmt.Println(val, ok) // 0, false (канал закрыт и пуст)
```

### Чтение из nil-канала (`<-nilCh`)

Если канал не инициализирован (нет `make(chan TYPE)`)), то:
- Операция `<-nilCh` **блокирует горутину навсегда** (deadlock).
- Если в `select` есть `case <-nilCh`, этот `case` **игнорируется**.

```go
var nilCh chan int
go func() {
    nilCh <- 42 // Блокируется навсегда
}()
fmt.Println(<-nilCh) // Блокируется навсегда
```

### Закрытие nil-канала (`close(nilCh)`)

Будет panic.

```go
var nilCh chan int
close(nilCh) // Паника!
```

### Детально

#### Где создаются каналы - в стэке или куче?

Каналы всегда создаются в куче

#### Какой объём памяти требует канал?

Канал занимает 8 байт. [Источник](https://habr.com/ru/articles/861846/).

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	ch := make(chan int)

	fmt.Println("channel size:", unsafe.Sizeof(ch))
}

// Output:
// channel size: 8
```

#### Могут ли незакрытые каналы привести к утечке горутин?

Да могут. 
[Источник](https://habr.com/ru/articles/861846/).

#### Влияет ли наличие и заполненность буфера у канала на работу GC?

GC удаляет как закрытые, так и незакрытые каналы. Наличие и заполненность буфера у канала тоже никакого влияния не оказывает на работу GC.
[Источник](https://habr.com/ru/articles/861846/).
