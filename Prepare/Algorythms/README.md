# –ê–ª–≥–æ—Ä–∏—Ç–º—ã –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

–ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏:
- [NeetCode ‚Äî —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ + –≤–∏–¥–µ–æ](https://neetcode.io/)
- [LeetCode ‚Äî –∑–∞–¥–∞—á–∏ –¥–ª—è –ø—Ä–∞–∫—Ç–∏–∫–∏](https://leetcode.com/)
- [LeetCode Top Interview 150](https://leetcode.com/studyplan/top-interview-150/) ‚Äî 150 –∑–∞–¥–∞—á –æ—Ç LeetCode
- [NeetCode 150](https://neetcode.io/practice) ‚Äî 150 –∑–∞–¥–∞—á —Å —Ä–∞–∑–±–æ—Ä–æ–º –Ω–∞ –≤–∏–¥–µ–æ
- [Blind 75 LeetCode](https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions) ‚Äî 75 –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á
- [Visualgo ‚Äî –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤](https://visualgo.net/)
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/)

---

## –û—Ü–µ–Ω–∫–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ (Big O)

**Big O** ‚Äî –æ–ø–∏—Å—ã–≤–∞–µ—Ç –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (–Ω–∞–∏—Ö—É–¥—à–∏–π —Å–ª—É—á–∞–π).

```
O(1)        < O(log n)  < O(n)  < O(n log n) < O(n¬≤) < O(2‚Åø) < O(n!)
–∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞    –ª–æ–≥–∞—Ä–∏—Ñ–º    –ª–∏–Ω–µ–π–Ω–∞—è  –ª–∏–Ω–µ–π–Ω–æ-–ª–æ–≥  –∫–≤–∞–¥—Ä–∞—Ç  —ç–∫—Å–ø–æ–Ω–µ–Ω—Ç–∞ —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª
```

| –°–ª–æ–∂–Ω–æ—Å—Ç—å | 10 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ | 100 | 10,000 | –ü—Ä–∏–º–µ—Ä |
|-----------|-------------|-----|--------|--------|
| O(1) | 1 | 1 | 1 | –î–æ—Å—Ç—É–ø –∫ —ç–ª–µ–º–µ–Ω—Ç—É –º–∞—Å—Å–∏–≤–∞ |
| O(log n) | 3 | 7 | 14 | –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ |
| O(n) | 10 | 100 | 10,000 | –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ |
| O(n log n) | 30 | 700 | 140,000 | Merge sort, Heap sort |
| O(n¬≤) | 100 | 10,000 | 10‚Å∏ | Bubble sort, –≤–ª–æ–∂–µ–Ω–Ω—ã–π —Ü–∏–∫–ª |
| O(2‚Åø) | 1024 | 10¬≥‚Å∞ | ‚Äî | –í—Å–µ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ |
| O(n!) | 3.6M | ‚Äî | ‚Äî | –í—Å–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ |

**–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å** (–ø–∞–º—è—Ç—å) —Ç–æ–∂–µ –æ—Ü–µ–Ω–∏–≤–∞–µ—Ç—Å—è Big O.

---

## –ë–∞–∑–æ–≤—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö

### –ú–∞—Å—Å–∏–≤ (Array)

```go
arr := [5]int{1, 2, 3, 4, 5}  // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
sl  := []int{1, 2, 3, 4, 5}   // —Å–ª–∞–π—Å (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π)
```

| –û–ø–µ—Ä–∞—Ü–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----------|-----------|
| –î–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É | O(1) |
| –ü–æ–∏—Å–∫ | O(n) |
| –í—Å—Ç–∞–≤–∫–∞/—É–¥–∞–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü | O(1) amortized |
| –í—Å—Ç–∞–≤–∫–∞/—É–¥–∞–ª–µ–Ω–∏–µ –≤ —Å–µ—Ä–µ–¥–∏–Ω—É | O(n) |

### –°–≤—è–∑–Ω—ã–π —Å–ø–∏—Å–æ–∫ (Linked List)

```go
type ListNode struct {
    Val  int
    Next *ListNode
}
```

| –û–ø–µ—Ä–∞—Ü–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----------|-----------|
| –î–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É | O(n) |
| –í—Å—Ç–∞–≤–∫–∞/—É–¥–∞–ª–µ–Ω–∏–µ –≤ –Ω–∞—á–∞–ª–æ | O(1) |
| –í—Å—Ç–∞–≤–∫–∞/—É–¥–∞–ª–µ–Ω–∏–µ –≤ –∫–æ–Ω–µ—Ü | O(1) —Å tail-pointer |
| –ü–æ–∏—Å–∫ | O(n) |

**–ó–∞–¥–∞—á–∏:**
- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) ‚≠ê
- [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/) ‚≠ê
- [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) ‚≠ê
- [19. Remove Nth Node From End](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
- [143. Reorder List](https://leetcode.com/problems/reorder-list/)
- [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/) üî•

### –°—Ç–µ–∫ (Stack) ‚Äî LIFO

```go
// –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–∞–π—Å –∫–∞–∫ —Å—Ç–µ–∫
stack := []int{}
stack = append(stack, 1)        // push
val := stack[len(stack)-1]      // peek
stack = stack[:len(stack)-1]    // pop
```

**–ó–∞–¥–∞—á–∏:**
- [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/) ‚≠ê
- [155. Min Stack](https://leetcode.com/problems/min-stack/) ‚≠ê
- [739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)
- [84. Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/) üî•

### –û—á–µ—Ä–µ–¥—å (Queue) ‚Äî FIFO

```go
// –î–≤—É—Å—Ç–æ—Ä–æ–Ω–Ω—è—è –æ—á–µ—Ä–µ–¥—å (deque)
import "container/list"
q := list.New()
q.PushBack(1)
q.Front().Value
q.Remove(q.Front())
```

**–ó–∞–¥–∞—á–∏:**
- [225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)
- [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)
- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) üî•

### HashMap

```go
m := make(map[string]int)
m["key"] = 1
if v, ok := m["key"]; ok { use(v) }
delete(m, "key")
```

| –û–ø–µ—Ä–∞—Ü–∏—è | –°—Ä–µ–¥–Ω–∏–π | –•—É–¥—à–∏–π |
|----------|---------|--------|
| Get/Set/Delete | O(1) | O(n) |

**–ó–∞–¥–∞—á–∏:**
- [1. Two Sum](https://leetcode.com/problems/two-sum/) ‚≠ê
- [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/) ‚≠ê
- [128. Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)
- [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

---

## –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø–æ–∏—Å–∫–∞

### –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–∏—Å–∫ ‚Äî O(n)

```go
func linearSearch(arr []int, target int) int {
    for i, v := range arr {
        if v == target {
            return i
        }
    }
    return -1
}
```

### –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫ ‚Äî O(log n)

–¢—Ä–µ–±—É–µ—Ç **–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ** –º–∞—Å—Å–∏–≤–∞.

```go
func binarySearch(arr []int, target int) int {
    left, right := 0, len(arr)-1
    for left <= right {
        mid := left + (right-left)/2  // –∏–∑–±–µ–≥–∞–µ–º overflow vs (l+r)/2
        if arr[mid] == target {
            return mid
        } else if arr[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return -1
}
```

**–ó–∞–¥–∞—á–∏:**
- [704. Binary Search](https://leetcode.com/problems/binary-search/) ‚≠ê
- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) ‚≠ê
- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/) üî•

---

## –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏

### Bubble Sort ‚Äî O(n¬≤)

```go
func bubbleSort(arr []int) {
    n := len(arr)
    for i := 0; i < n-1; i++ {
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}
```

### Merge Sort ‚Äî O(n log n), —Å—Ç–∞–±–∏–ª—å–Ω–∞—è

–†–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞—Å—Ç–≤—É–π (Divide & Conquer):

```go
func mergeSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    mid := len(arr) / 2
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
    return merge(left, right)
}

func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    i, j := 0, 0
    for i < len(left) && j < len(right) {
        if left[i] <= right[j] {
            result = append(result, left[i])
            i++
        } else {
            result = append(result, right[j])
            j++
        }
    }
    result = append(result, left[i:]...)
    result = append(result, right[j:]...)
    return result
}
```

### Quick Sort ‚Äî O(n log n) avg, O(n¬≤) worst

```go
func quickSort(arr []int, low, high int) {
    if low < high {
        pivot := partition(arr, low, high)
        quickSort(arr, low, pivot-1)
        quickSort(arr, pivot+1, high)
    }
}

func partition(arr []int, low, high int) int {
    pivot := arr[high]
    i := low - 1
    for j := low; j < high; j++ {
        if arr[j] <= pivot {
            i++
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    arr[i+1], arr[high] = arr[high], arr[i+1]
    return i + 1
}
```

### Heap Sort ‚Äî O(n log n), in-place

```go
func heapSort(arr []int) {
    n := len(arr)
    // –°—Ç—Ä–æ–∏–º max-heap
    for i := n/2 - 1; i >= 0; i-- {
        heapify(arr, n, i)
    }
    // –ò–∑–≤–ª–µ–∫–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã
    for i := n - 1; i > 0; i-- {
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)
    }
}

func heapify(arr []int, n, i int) {
    largest, l, r := i, 2*i+1, 2*i+2
    if l < n && arr[l] > arr[largest] { largest = l }
    if r < n && arr[r] > arr[largest] { largest = r }
    if largest != i {
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)
    }
}
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏

| –ê–ª–≥–æ—Ä–∏—Ç–º | –õ—É—á—à–∏–π | –°—Ä–µ–¥–Ω–∏–π | –•—É–¥—à–∏–π | –ü–∞–º—è—Ç—å | –°—Ç–∞–±–∏–ª—å–Ω–∞—è |
|---------|--------|---------|--------|--------|-----------|
| Bubble Sort | O(n) | O(n¬≤) | O(n¬≤) | O(1) | –î–∞ |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | **–î–∞** |
| Quick Sort | O(n log n) | O(n log n) | O(n¬≤) | O(log n) | –ù–µ—Ç |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) | –ù–µ—Ç |
| Counting Sort | O(n+k) | O(n+k) | O(n+k) | O(k) | –î–∞ |
| Go `slices.Sort` | ‚Äî | O(n log n) | O(n log n) | O(log n) | –ù–µ—Ç (pdqsort) |

**–ó–∞–¥–∞—á–∏:**
- [912. Sort an Array](https://leetcode.com/problems/sort-an-array/)
- [215. Kth Largest Element](https://leetcode.com/problems/kth-largest-element-in-an-array/) ‚≠ê

---

## –î–µ—Ä–µ–≤—å—è (Trees)

### –ë–∏–Ω–∞—Ä–Ω–æ–µ –¥–µ—Ä–µ–≤–æ –ø–æ–∏—Å–∫–∞ (BST)

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}
```

**–°–≤–æ–π—Å—Ç–≤–æ BST**: `left.Val < root.Val < right.Val` (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ).

| –û–ø–µ—Ä–∞—Ü–∏—è | –°—Ä–µ–¥–Ω–∏–π | –•—É–¥—à–∏–π (–Ω–µ—Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ) |
|----------|---------|----------------------------|
| –ü–æ–∏—Å–∫ | O(log n) | O(n) |
| –í—Å—Ç–∞–≤–∫–∞ | O(log n) | O(n) |
| –£–¥–∞–ª–µ–Ω–∏–µ | O(log n) | O(n) |

### –û–±—Ö–æ–¥—ã –¥–µ—Ä–µ–≤–∞ (Tree Traversals)

```go
// Preorder: root ‚Üí left ‚Üí right
func preorder(root *TreeNode) []int {
    if root == nil { return nil }
    res := []int{root.Val}
    res = append(res, preorder(root.Left)...)
    res = append(res, preorder(root.Right)...)
    return res
}

// Inorder: left ‚Üí root ‚Üí right (–¥–∞—ë—Ç –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –¥–ª—è BST!)
func inorder(root *TreeNode) []int {
    if root == nil { return nil }
    res := inorder(root.Left)
    res = append(res, root.Val)
    res = append(res, inorder(root.Right)...)
    return res
}

// Postorder: left ‚Üí right ‚Üí root
func postorder(root *TreeNode) []int {
    if root == nil { return nil }
    res := postorder(root.Left)
    res = append(res, postorder(root.Right)...)
    res = append(res, root.Val)
    return res
}

// BFS (Level-order) ‚Äî –æ–±—Ö–æ–¥ –ø–æ —É—Ä–æ–≤–Ω—è–º
func levelOrder(root *TreeNode) [][]int {
    if root == nil { return nil }
    result := [][]int{}
    queue := []*TreeNode{root}

    for len(queue) > 0 {
        levelSize := len(queue)
        level := make([]int, levelSize)
        for i := 0; i < levelSize; i++ {
            node := queue[i]
            level[i] = node.Val
            if node.Left != nil  { queue = append(queue, node.Left) }
            if node.Right != nil { queue = append(queue, node.Right) }
        }
        queue = queue[levelSize:]
        result = append(result, level)
    }
    return result
}
```

### –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π DFS (—Å–æ —Å—Ç–µ–∫–æ–º)

```go
func inorderIterative(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
    curr := root

    for curr != nil || len(stack) > 0 {
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, curr.Val)
        curr = curr.Right
    }
    return result
}
```

### –ó–∞–¥–∞—á–∏ –ø–æ –¥–µ—Ä–µ–≤—å—è–º

- [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/) ‚≠ê
- [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) ‚≠ê
- [100. Same Tree](https://leetcode.com/problems/same-tree/) ‚≠ê
- [572. Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)
- [235. Lowest Common Ancestor of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) ‚≠ê
- [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) ‚≠ê
- [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) ‚≠ê
- [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) üî•
- [297. Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/) üî•

### –°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–µ—Ä–µ–≤—å—è

**AVL Tree** ‚Äî —Å–∞–º–æ–±–∞–ª–∞–Ω—Å–∏—Ä—É—é—â–µ–µ—Å—è BST:
- `|height(left) - height(right)| <= 1` –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É–∑–ª–∞.
- –û–ø–µ—Ä–∞—Ü–∏–∏: O(log n) –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–æ.
- –î–æ—Ä–æ–∂–µ –≤—Å—Ç–∞–≤–∫–∏/—É–¥–∞–ª–µ–Ω–∏—è (–Ω—É–∂–Ω—ã —Ä–æ—Ç–∞—Ü–∏–∏).

**Red-Black Tree** ‚Äî –¥—Ä—É–≥–æ–µ —Å–∞–º–æ–±–∞–ª–∞–Ω—Å–∏—Ä—É—é—â–µ–µ—Å—è BST:
- –ú–µ–Ω–µ–µ —Å—Ç—Ä–æ–≥–æ —Å–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–æ, —á–µ–º AVL.
- –ë—ã—Å—Ç—Ä–µ–µ –≤—Å—Ç–∞–≤–∫–∏/—É–¥–∞–ª–µ–Ω–∏—è, —á—É—Ç—å –º–µ–¥–ª–µ–Ω–Ω–µ–µ –ø–æ–∏—Å–∫–∞.
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤: `std::map` (C++), Java `TreeMap`, `database/sql` connection pools.

### Heap (–ö—É—á–∞) ‚Äî Priority Queue

**Min-Heap**: —Ä–æ–¥–∏—Ç–µ–ª—å ‚â§ –¥–µ—Ç–µ–π. –ö–æ—Ä–µ–Ω—å ‚Äî –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.
**Max-Heap**: —Ä–æ–¥–∏—Ç–µ–ª—å ‚â• –¥–µ—Ç–µ–π. –ö–æ—Ä–µ–Ω—å ‚Äî –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç.

```go
import "container/heap"

// Min-heap –≤ Go
type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *MinHeap) Push(x any)        { *h = append(*h, x.(int)) }
func (h *MinHeap) Pop() any {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[:n-1]
    return x
}

h := &MinHeap{3, 1, 4, 1, 5}
heap.Init(h)
heap.Push(h, 2)
min := heap.Pop(h).(int) // 1
```

| –û–ø–µ—Ä–∞—Ü–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----------|-----------|
| Push | O(log n) |
| Pop (min/max) | O(log n) |
| Peek (min/max) | O(1) |
| Build heap | O(n) |

**–ó–∞–¥–∞—á–∏:**
- [703. Kth Largest in Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/) ‚≠ê
- [1046. Last Stone Weight](https://leetcode.com/problems/last-stone-weight/)
- [973. K Closest Points](https://leetcode.com/problems/k-closest-points-to-origin/)
- [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/) üî•

### Trie (–ü—Ä–µ—Ñ–∏–∫—Å–Ω–æ–µ –¥–µ—Ä–µ–≤–æ)

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –ø–æ–∏—Å–∫–∞ —Å—Ç—Ä–æ–∫ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É:

```go
type TrieNode struct {
    children [26]*TrieNode
    isEnd    bool
}

type Trie struct {
    root *TrieNode
}

func (t *Trie) Insert(word string) {
    node := t.root
    for _, ch := range word {
        idx := ch - 'a'
        if node.children[idx] == nil {
            node.children[idx] = &TrieNode{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t.root
    for _, ch := range word {
        idx := ch - 'a'
        if node.children[idx] == nil { return false }
        node = node.children[idx]
    }
    return node.isEnd
}
```

| –û–ø–µ—Ä–∞—Ü–∏—è | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|----------|-----------|
| Insert | O(m) ‚Äî m = –¥–ª–∏–Ω–∞ —Å–ª–æ–≤–∞ |
| Search | O(m) |
| StartsWith | O(m) |

**–ó–∞–¥–∞—á–∏:**
- [208. Implement Trie](https://leetcode.com/problems/implement-trie-prefix-tree/) ‚≠ê
- [211. Design Add and Search Words](https://leetcode.com/problems/design-add-and-search-words-data-structure/)
- [212. Word Search II](https://leetcode.com/problems/word-search-ii/) üî•

---

## –ì—Ä–∞—Ñ—ã (Graphs)

### –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≥—Ä–∞—Ñ–∞

```go
// –°–ø–∏—Å–æ–∫ —Å–º–µ–∂–Ω–æ—Å—Ç–∏ (adjacency list) ‚Äî —á–∞—â–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
graph := map[int][]int{
    0: {1, 2},
    1: {0, 3},
    2: {0, 4},
    3: {1},
    4: {2},
}

// –ú–∞—Ç—Ä–∏—Ü–∞ —Å–º–µ–∂–Ω–æ—Å—Ç–∏ ‚Äî –¥–ª—è –ø–ª–æ—Ç–Ω—ã—Ö –≥—Ä–∞—Ñ–æ–≤
adj := make([][]int, n)
for i := range adj {
    adj[i] = make([]int, n)
}
adj[0][1] = 1 // –µ—Å—Ç—å —Ä–µ–±—Ä–æ 0‚Üí1
```

### BFS –Ω–∞ –≥—Ä–∞—Ñ–µ ‚Äî O(V + E)

```go
func bfs(graph map[int][]int, start int) []int {
    visited := make(map[int]bool)
    queue := []int{start}
    visited[start] = true
    result := []int{}

    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        result = append(result, node)

        for _, neighbor := range graph[node] {
            if !visited[neighbor] {
                visited[neighbor] = true
                queue = append(queue, neighbor)
            }
        }
    }
    return result
}
```

### DFS –Ω–∞ –≥—Ä–∞—Ñ–µ ‚Äî O(V + E)

```go
func dfs(graph map[int][]int, node int, visited map[int]bool, result *[]int) {
    visited[node] = true
    *result = append(*result, node)

    for _, neighbor := range graph[node] {
        if !visited[neighbor] {
            dfs(graph, neighbor, visited, result)
        }
    }
}
```

### –ó–∞–¥–∞—á–∏ BFS/DFS –Ω–∞ –≥—Ä–∞—Ñ–∞—Ö

- [200. Number of Islands](https://leetcode.com/problems/number-of-islands/) ‚≠ê (DFS/BFS –Ω–∞ —Å–µ—Ç–∫–µ)
- [133. Clone Graph](https://leetcode.com/problems/clone-graph/) ‚≠ê
- [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)
- [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)
- [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) ‚≠ê (Multi-source BFS)
- [417. Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)
- [127. Word Ladder](https://leetcode.com/problems/word-ladder/) üî•

### –ê–ª–≥–æ—Ä–∏—Ç–º –î–µ–π–∫—Å—Ç—Ä—ã ‚Äî –∫—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å O((V+E) log V)

–î–ª—è –≤–∑–≤–µ—à–µ–Ω–Ω—ã—Ö –≥—Ä–∞—Ñ–æ–≤ —Å **–Ω–µ–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏** –≤–µ—Å–∞–º–∏:

```go
import "container/heap"

type Item struct {
    node, cost int
}
type PQ []Item
func (pq PQ) Len() int            { return len(pq) }
func (pq PQ) Less(i, j int) bool  { return pq[i].cost < pq[j].cost }
func (pq PQ) Swap(i, j int)       { pq[i], pq[j] = pq[j], pq[i] }
func (pq *PQ) Push(x any)         { *pq = append(*pq, x.(Item)) }
func (pq *PQ) Pop() any {
    old := *pq; n := len(old); x := old[n-1]; *pq = old[:n-1]; return x
}

func dijkstra(graph map[int][][2]int, start, end int) int {
    dist := make(map[int]int)
    pq := &PQ{{start, 0}}
    heap.Init(pq)

    for pq.Len() > 0 {
        curr := heap.Pop(pq).(Item)
        node, cost := curr.node, curr.cost

        if node == end { return cost }
        if d, ok := dist[node]; ok && cost >= d { continue }
        dist[node] = cost

        for _, edge := range graph[node] {
            neighbor, weight := edge[0], edge[1]
            heap.Push(pq, Item{neighbor, cost + weight})
        }
    }
    return -1
}
```

### –ê–ª–≥–æ—Ä–∏—Ç–º –ë–µ–ª–ª–º–∞–Ω–∞-–§–æ—Ä–¥–∞ ‚Äî O(V * E)

–†–∞–±–æ—Ç–∞–µ—Ç —Å **–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏** –≤–µ—Å–∞–º–∏. –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —Ü–∏–∫–ª—ã.

```go
func bellmanFord(edges [][3]int, n, src int) []int {
    dist := make([]int, n)
    for i := range dist { dist[i] = 1<<31 - 1 }
    dist[src] = 0

    for i := 0; i < n-1; i++ {
        for _, e := range edges { // [u, v, weight]
            u, v, w := e[0], e[1], e[2]
            if dist[u] != 1<<31-1 && dist[u]+w < dist[v] {
                dist[v] = dist[u] + w
            }
        }
    }
    return dist
}
```

### –¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ (DAG) ‚Äî O(V + E)

–î–ª—è –æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∞—Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –≥—Ä–∞—Ñ–æ–≤ (DAG):

```go
// –ê–ª–≥–æ—Ä–∏—Ç–º –ö–∞–Ω–∞ (—á–µ—Ä–µ–∑ in-degree)
func topoSort(n int, edges [][2]int) []int {
    inDegree := make([]int, n)
    graph := make([][]int, n)

    for _, e := range edges {
        graph[e[0]] = append(graph[e[0]], e[1])
        inDegree[e[1]]++
    }

    queue := []int{}
    for i, d := range inDegree {
        if d == 0 { queue = append(queue, i) }
    }

    result := []int{}
    for len(queue) > 0 {
        node := queue[0]; queue = queue[1:]
        result = append(result, node)
        for _, neighbor := range graph[node] {
            inDegree[neighbor]--
            if inDegree[neighbor] == 0 {
                queue = append(queue, neighbor)
            }
        }
    }
    if len(result) != n { return nil } // –µ—Å—Ç—å —Ü–∏–∫–ª
    return result
}
```

### Union-Find (Disjoint Set Union ‚Äî DSU)

–î–ª—è –∑–∞–¥–∞—á —Å–≤—è–∑–Ω–æ—Å—Ç–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç:

```go
type DSU struct {
    parent, rank []int
}

func NewDSU(n int) *DSU {
    d := &DSU{parent: make([]int, n), rank: make([]int, n)}
    for i := range d.parent { d.parent[i] = i }
    return d
}

func (d *DSU) Find(x int) int {
    if d.parent[x] != x {
        d.parent[x] = d.Find(d.parent[x]) // path compression
    }
    return d.parent[x]
}

func (d *DSU) Union(x, y int) bool {
    px, py := d.Find(x), d.Find(y)
    if px == py { return false } // —É–∂–µ –≤ –æ–¥–Ω–æ–º –º–Ω–æ–∂–µ—Å—Ç–≤–µ
    // union by rank
    if d.rank[px] < d.rank[py] { px, py = py, px }
    d.parent[py] = px
    if d.rank[px] == d.rank[py] { d.rank[px]++ }
    return true
}
```

**–ó–∞–¥–∞—á–∏ –ø–æ –≥—Ä–∞—Ñ–∞–º:**
- [207. Course Schedule](https://leetcode.com/problems/course-schedule/) ‚≠ê (–¢–æ–ø–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞)
- [210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)
- [323. Number of Connected Components](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)
- [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/) (DSU)
- [743. Network Delay Time](https://leetcode.com/problems/network-delay-time/) ‚≠ê (–î–µ–π–∫—Å—Ç—Ä–∞)
- [787. Cheapest Flights](https://leetcode.com/problems/cheapest-flights-within-k-stops/) üî•
- [269. Alien Dictionary](https://leetcode.com/problems/alien-dictionary/) üî•

---

## –ü–∞—Ç—Ç–µ—Ä–Ω—ã —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á (Patterns)

### Two Pointers ‚Äî O(n)

–î–≤–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –¥–≤–∏–∂—É—Ç—Å—è –ø–æ –º–∞—Å—Å–∏–≤—É/—Å—Ç—Ä–æ–∫–µ:

```go
// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–ª–∏–Ω–¥—Ä–æ–º–∞
func isPalindrome(s string) bool {
    l, r := 0, len(s)-1
    for l < r {
        if s[l] != s[r] { return false }
        l++; r--
    }
    return true
}

// –ó–∞–¥–∞—á–∏
// 125. Valid Palindrome
// 167. Two Sum II (sorted)    ‚≠ê
// 15. 3Sum                    ‚≠ê
// 11. Container With Most Water ‚≠ê
```

### Sliding Window ‚Äî O(n)

–û–∫–Ω–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞:

```go
// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–¥–º–∞—Å—Å–∏–≤–∞ –¥–ª–∏–Ω—ã k
func maxSumSubarray(arr []int, k int) int {
    sum, maxSum := 0, 0
    for i := 0; i < k; i++ { sum += arr[i] }
    maxSum = sum
    for i := k; i < len(arr); i++ {
        sum += arr[i] - arr[i-k]
        if sum > maxSum { maxSum = sum }
    }
    return maxSum
}

// –ó–∞–¥–∞—á–∏:
// 121. Best Time to Buy Stock       ‚≠ê
// 3. Longest Substring Without Repeating ‚≠ê
// 424. Longest Repeating Char Replacement
// 76. Minimum Window Substring     üî•
```

### Fast & Slow Pointers (Floyd's Cycle Detection)

```go
// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ü–∏–∫–ª–∞ –≤ Linked List
func hasCycle(head *ListNode) bool {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast { return true }
    }
    return false
}

// –ó–∞–¥–∞—á–∏:
// 141. Linked List Cycle             ‚≠ê
// 142. Linked List Cycle II
// 287. Find the Duplicate Number    üî•
```

---

## –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ (Dynamic Programming)

DP = —Ä–∞–∑–±–∏–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –Ω–∞ –ø–æ–¥–∑–∞–¥–∞—á–∏ + –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ—à–µ–Ω–∏–π.

**–ü—Ä–∏–∑–Ω–∞–∫–∏ DP –∑–∞–¥–∞—á–∏:**
- –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ (min/max/count).
- –ü–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –ø–æ–¥–∑–∞–¥–∞—á–∏.
- –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –ø–æ–¥—Å—Ç—Ä—É–∫—Ç—É—Ä–∞.

### 1D DP ‚Äî Fibonacci / Climbing Stairs

```go
// –ë–µ–∑ –º–µ–º–æ–∏–∑–∞—Ü–∏–∏: O(2‚Åø)
// –° –º–µ–º–æ–∏–∑–∞—Ü–∏–µ–π: O(n) –≤—Ä–µ–º—è, O(n) –ø–∞–º—è—Ç—å
// Tabulation (bottom-up): O(n) –≤—Ä–µ–º—è, O(1) –ø–∞–º—è—Ç—å

func climbStairs(n int) int {
    if n <= 2 { return n }
    a, b := 1, 2
    for i := 3; i <= n; i++ {
        a, b = b, a+b
    }
    return b
}
```

**–ó–∞–¥–∞—á–∏ 1D DP:**
- [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) ‚≠ê
- [198. House Robber](https://leetcode.com/problems/house-robber/) ‚≠ê
- [322. Coin Change](https://leetcode.com/problems/coin-change/) ‚≠ê
- [300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) ‚≠ê
- [139. Word Break](https://leetcode.com/problems/word-break/)

### 2D DP ‚Äî Unique Paths / Knapsack

```go
// –£–Ω–∏–∫–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏ –≤ —Å–µ—Ç–∫–µ m√ón
func uniquePaths(m, n int) int {
    dp := make([][]int, m)
    for i := range dp { dp[i] = make([]int, n) }
    for i := 0; i < m; i++ { dp[i][0] = 1 }
    for j := 0; j < n; j++ { dp[0][j] = 1 }
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i-1][j] + dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```

**–ó–∞–¥–∞—á–∏ 2D DP:**
- [62. Unique Paths](https://leetcode.com/problems/unique-paths/)
- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) ‚≠ê
- [72. Edit Distance](https://leetcode.com/problems/edit-distance/) üî•
- [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
- [518. Coin Change II](https://leetcode.com/problems/coin-change-ii/)

### –ó–∞–¥–∞—á–∏ –Ω–∞ –ø–æ–¥—Å—Ç—Ä–æ–∫–∏/–ø–æ–¥–º–∞—Å—Å–∏–≤—ã:
- [5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/) ‚≠ê
- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)

---

## –ê–ª–≥–æ—Ä–∏—Ç–º –•–∞—Ñ—Ñ–º–∞–Ω–∞ (Huffman Coding)

–ê–ª–≥–æ—Ä–∏—Ç–º **—Å–∂–∞—Ç–∏—è –¥–∞–Ω–Ω—ã—Ö –±–µ–∑ –ø–æ—Ç–µ—Ä—å** (lossless compression). –ê–≤—Ç–æ—Ä: –î—ç–≤–∏–¥ –•–∞—Ñ—Ñ–º–∞–Ω, 1952.

**–ò–¥–µ—è**: —á–∞—Å—Ç—ã–µ —Å–∏–º–≤–æ–ª—ã –∫–æ–¥–∏—Ä—É—é—Ç—Å—è –∫–æ—Ä–æ—Ç–∫–∏–º–∏ –±–∏—Ç–æ–≤—ã–º–∏ –∫–æ–¥–∞–º–∏, —Ä–µ–¥–∫–∏–µ ‚Äî –¥–ª–∏–Ω–Ω—ã–º–∏.

### –ü—Ä–∏–º–µ—Ä

```
–¢–µ–∫—Å—Ç: "ABRACADABRA"
–ß–∞—Å—Ç–æ—Ç—ã: A=5, B=2, R=2, C=1, D=1

–®–∞–≥ 1: —Å–æ–∑–¥–∞—ë–º —É–∑–ª—ã, —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —á–∞—Å—Ç–æ—Ç–µ
[C:1] [D:1] [B:2] [R:2] [A:5]

–®–∞–≥ 2: –æ–±—ä–µ–¥–∏–Ω—è–µ–º –¥–≤–∞ –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö ‚Üí –Ω–æ–≤—ã–π —É–∑–µ–ª
[CD:2] [B:2] [R:2] [A:5]

–®–∞–≥ 3: —Å–Ω–æ–≤–∞ –æ–±—ä–µ–¥–∏–Ω—è–µ–º –Ω–∞–∏–º–µ–Ω—å—à–∏–µ
[B+CD:4] [R:2] [A:5]
‚Üí [B+R+CD:6] [A:5]
‚Üí [A+B+R+CD:11]

–î–µ—Ä–µ–≤–æ:
       [11]
      /    \
   [A:5]  [6]
          /  \
       [B:2] [4]
             /  \
          [R:2] [CD:2]
                /   \
            [C:1] [D:1]

–ö–æ–¥—ã:
A = 0         (1 –±–∏—Ç, —Å–∞–º—ã–π —á–∞—Å—Ç—ã–π!)
B = 10        (2 –±–∏—Ç–∞)
R = 110       (3 –±–∏—Ç–∞)
C = 1110      (4 –±–∏—Ç–∞)
D = 1111      (4 –±–∏—Ç–∞)
```

**–ë–µ–∑ —Å–∂–∞—Ç–∏—è** (ASCII): 11 —Å–∏–º–≤–æ–ª–æ–≤ √ó 8 –±–∏—Ç = 88 –±–∏—Ç.
**–° –•–∞—Ñ—Ñ–º–∞–Ω–æ–º**: 5√ó1 + 2√ó2 + 2√ó3 + 1√ó4 + 1√ó4 = 5+4+6+4+4 = **23 –±–∏—Ç–∞**.

### –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ Go

```go
import "container/heap"

type HuffNode struct {
    char  rune
    freq  int
    left  *HuffNode
    right *HuffNode
}

type NodeHeap []*HuffNode

func (h NodeHeap) Len() int           { return len(h) }
func (h NodeHeap) Less(i, j int) bool { return h[i].freq < h[j].freq }
func (h NodeHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *NodeHeap) Push(x any)        { *h = append(*h, x.(*HuffNode)) }
func (h *NodeHeap) Pop() any {
    old := *h; n := len(old); x := old[n-1]; *h = old[:n-1]; return x
}

func BuildHuffmanTree(freq map[rune]int) *HuffNode {
    h := &NodeHeap{}
    for ch, f := range freq {
        heap.Push(h, &HuffNode{char: ch, freq: f})
    }

    for h.Len() > 1 {
        left := heap.Pop(h).(*HuffNode)
        right := heap.Pop(h).(*HuffNode)
        parent := &HuffNode{
            freq:  left.freq + right.freq,
            left:  left,
            right: right,
        }
        heap.Push(h, parent)
    }
    return heap.Pop(h).(*HuffNode)
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–æ–≤ (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥)
func GenerateCodes(node *HuffNode, prefix string, codes map[rune]string) {
    if node == nil { return }
    if node.left == nil && node.right == nil {
        codes[node.char] = prefix // –ª–∏—Å—Ç–æ–≤–æ–π —É–∑–µ–ª
        return
    }
    GenerateCodes(node.left, prefix+"0", codes)
    GenerateCodes(node.right, prefix+"1", codes)
}
```

### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –•–∞—Ñ—Ñ–º–∞–Ω–∞

- **gzip, zlib** ‚Äî –∏—Å–ø–æ–ª—å–∑—É—é—Ç –•–∞—Ñ—Ñ–º–∞–Ω –∫–∞–∫ —á–∞—Å—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º–∞ Deflate.
- **JPEG** ‚Äî —Å–∂–∞—Ç–∏–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ DCT.
- **MP3** ‚Äî –•–∞—Ñ—Ñ–º–∞–Ω –¥–ª—è —á–∞—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö.
- **HPACK (HTTP/2)** ‚Äî —Å–∂–∞—Ç–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤.
- **ZIP** ‚Äî —á–∞—Å—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Å–∂–∞—Ç–∏—è.

**–°–≤–æ–π—Å—Ç–≤–∞:**
- –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –¥–µ—Ä–µ–≤–∞: O(n log n).
- –û–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è –ø–æ—Å–∏–º–≤–æ–ª—å–Ω–æ–≥–æ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è (prefix-free codes).
- –ù–µ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ –¥–ª—è –±–ª–æ–∫–æ–≤ —Å–∏–º–≤–æ–ª–æ–≤ (—Ç–æ–≥–¥–∞ ‚Äî –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ).

---

## –†–µ–∫—É—Ä—Å–∏—è –∏ Backtracking

### Backtracking (–ø–µ—Ä–µ–±–æ—Ä —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º)

```go
// –í—Å–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –º–∞—Å—Å–∏–≤–∞
func permute(nums []int) [][]int {
    result := [][]int{}
    var backtrack func(start int)
    backtrack = func(start int) {
        if start == len(nums) {
            perm := make([]int, len(nums))
            copy(perm, nums)
            result = append(result, perm)
            return
        }
        for i := start; i < len(nums); i++ {
            nums[start], nums[i] = nums[i], nums[start]
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start] // –æ—Ç–º–µ–Ω–∞
        }
    }
    backtrack(0)
    return result
}
```

**–ó–∞–¥–∞—á–∏:**
- [78. Subsets](https://leetcode.com/problems/subsets/) ‚≠ê
- [39. Combination Sum](https://leetcode.com/problems/combination-sum/) ‚≠ê
- [46. Permutations](https://leetcode.com/problems/permutations/) ‚≠ê
- [79. Word Search](https://leetcode.com/problems/word-search/) ‚≠ê
- [51. N-Queens](https://leetcode.com/problems/n-queens/) üî•

---

## –¢–æ–ø LeetCode –∑–∞–¥–∞—á –ø–æ —Ç–µ–º–∞–º (—Å —Å—Å—ã–ª–∫–∞–º–∏)

### Arrays & Hashing
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 217 | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) | Easy |
| 242 | [Valid Anagram](https://leetcode.com/problems/valid-anagram/) | Easy |
| 1 | [Two Sum](https://leetcode.com/problems/two-sum/) | Easy |
| 49 | [Group Anagrams](https://leetcode.com/problems/group-anagrams/) | Medium |
| 347 | [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/) | Medium |
| 128 | [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/) | Medium |

### Two Pointers
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 125 | [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/) | Easy |
| 167 | [Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | Medium |
| 15 | [3Sum](https://leetcode.com/problems/3sum/) | Medium |
| 11 | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/) | Medium |
| 42 | [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/) | Hard üî• |

### Sliding Window
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 121 | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) | Easy |
| 3 | [Longest Substring Without Repeating](https://leetcode.com/problems/longest-substring-without-repeating-characters/) | Medium |
| 424 | [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/) | Medium |
| 76 | [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/) | Hard üî• |

### Binary Search
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 704 | [Binary Search](https://leetcode.com/problems/binary-search/) | Easy |
| 74 | [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) | Medium |
| 33 | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/) | Medium |
| 153 | [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/) | Medium |

### Trees
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 226 | [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/) | Easy |
| 104 | [Maximum Depth](https://leetcode.com/problems/maximum-depth-of-binary-tree/) | Easy |
| 543 | [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/) | Easy |
| 110 | [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/) | Easy |
| 235 | [LCA of BST](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | Medium |
| 102 | [Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | Medium |
| 98 | [Validate BST](https://leetcode.com/problems/validate-binary-search-tree/) | Medium |
| 124 | [Max Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) | Hard üî• |

### Graphs
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 200 | [Number of Islands](https://leetcode.com/problems/number-of-islands/) | Medium |
| 133 | [Clone Graph](https://leetcode.com/problems/clone-graph/) | Medium |
| 994 | [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/) | Medium |
| 207 | [Course Schedule](https://leetcode.com/problems/course-schedule/) | Medium |
| 743 | [Network Delay Time](https://leetcode.com/problems/network-delay-time/) | Medium |
| 127 | [Word Ladder](https://leetcode.com/problems/word-ladder/) | Hard üî• |

### Dynamic Programming
| # | –ó–∞–¥–∞—á–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å |
|---|--------|----------|
| 70 | [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/) | Easy |
| 198 | [House Robber](https://leetcode.com/problems/house-robber/) | Medium |
| 322 | [Coin Change](https://leetcode.com/problems/coin-change/) | Medium |
| 300 | [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/) | Medium |
| 1143 | [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/) | Medium |
| 72 | [Edit Distance](https://leetcode.com/problems/edit-distance/) | Medium üî• |

---

## –†–µ—Å—É—Ä—Å—ã –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏

| –†–µ—Å—É—Ä—Å | –û–ø–∏—Å–∞–Ω–∏–µ |
|--------|---------|
| [NeetCode 150](https://neetcode.io/practice) | 150 –∑–∞–¥–∞—á —Å —Ä–∞–∑–±–æ—Ä–æ–º –Ω–∞ –≤–∏–¥–µ–æ –ø–æ –ø–∞—Ç—Ç–µ—Ä–Ω–∞–º |
| [LeetCode Blind 75](https://leetcode.com/discuss/general-discussion/460599/blind-75-leetcode-questions) | 75 —Å–∞–º—ã—Ö –≤–∞–∂–Ω—ã—Ö –∑–∞–¥–∞—á |
| [LeetCode Top Interview 150](https://leetcode.com/studyplan/top-interview-150/) | –û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –æ—Ç LeetCode |
| [Grind 169](https://www.techinterviewhandbook.org/grind75) | –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ (169 –∑–∞–¥–∞—á) |
| [Visualgo](https://visualgo.net/) | –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ |
| [Big-O Cheat Sheet](https://www.bigocheatsheet.com/) | –®–ø–∞—Ä–≥–∞–ª–∫–∞ –ø–æ —Å–ª–æ–∂–Ω–æ—Å—Ç—è–º |
| [CP Algorithms](https://cp-algorithms.com/) | –¢–µ–æ—Ä–∏—è + —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ |
