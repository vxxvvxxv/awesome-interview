### Что это?

**Рефлексия** позволяет анализировать и изменять типы и значения в runtime.
В частности, пакет `reflect` предоставляет инструменты для работы:
- с типами (`types`), 
- значениями (`values`), 
- структурами (`structs`), 
- функциями,
- и другими элементами языка динамически.

#### Основные понятия

##### Типы (`reflect.Type`)

Описывает **статическую информацию о типе** (например, имя типа, методы, поля структуры).  
Получить `reflect.Type` можно через `reflect.TypeOf(x)`.

##### Значения (`reflect.Value`)

Содержит **динамическую информацию о значении переменной** (например, само значение, можно ли его изменить).  
Получить `reflect.Value` можно через `reflect.ValueOf(x)`.

#### Примеры использования

##### Определение типа переменной

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x float64 = 3.14
	fmt.Println("Тип x:", reflect.TypeOf(x)) // float64
}

// Output:
// Тип x: float64
```

##### Анализ структуры (`struct`)

```go
type User struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	u := User{"Alice", 25}
	t := reflect.TypeOf(u)

	// Перебор полей структуры
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf(
			"Поле %d: Имя=%v, Тип=%v, Тег=`%v`\n",
			i, field.Name, field.Type, field.Tag,
		)
	}
}

// Output:
// Поле 0: Имя=Name, Тип=string, Тег=`json:"name"`
// Поле 1: Имя=Age, Тип=int, Тег=`json:"age"`
```

##### Изменение значения через рефлексию

```go
func main() {
	var x float64 = 3.14
	v := reflect.ValueOf(&x).Elem() // Elem() получает значение по указателю

	fmt.Println("До:", x)
	v.SetFloat(6.28) // Изменяем значение
	fmt.Println("После:", x)
}

// Output:
// До: 3.14
// После: 6.28
```

⚠️ **Важно:** Чтобы изменить значение, нужно передать **указатель** (`&x`) и вызвать `.Elem()`.

##### Динамический вызов функции

```go
func Add(a, b int) int {
	return a + b
}

func main() {
	funcValue := reflect.ValueOf(Add)
	args := []reflect.Value{reflect.ValueOf(2), reflect.ValueOf(3)}

	results := funcValue.Call(args)
	fmt.Println("Результат:", results[0].Int()) // 5
}

// Output:
// Результат: 5
```

### Когда использовать?

#### Полезные сценарии

- **Сериализация/десериализация** (например, `json.Marshal` использует рефлексию).
- **ORM-библиотеки** (анализ структуры БД-моделей).
- **Универсальные функции** (например, `fmt.Printf` анализирует типы аргументов).
- **Тестирование и моки** (динамический вызов методов).

#### Когда НЕ стоит использовать

- Если можно решить задачу **без рефлексии** (т.к. рефлексия - медленнее и менее безопасна).
- В критичных к производительности местах.
- Если код становится сложным для понимания.

### Ограничения

- **Нельзя создать новые типы** во время выполнения.
- **Нет доступа к неэкспортируемым полям** (с маленькой буквы) *без хаков*.
- **Медленнее**, чем статический код.
