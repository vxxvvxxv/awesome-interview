[Исходный код](https://github.com/golang/go/blob/master/src/runtime/slice.go).

---

Срез (**slice**) — это **динамическая обертка над массивом** (с указателем, длиной и ёмкостью).
Внутри он представлен структурой:

```go
type slice struct {
    array unsafe.Pointer // Указатель на базовый массив
    len   int            // Текущая длина (количество элементов)
    cap   int            // Ёмкость (максимальное количество элементов без переаллокации)
}
```

### В чём различие Slice и Массивов?

|Характеристика|**Массив**|**Срез (Slice)**|
|---|---|---|
|**Размер**|Фиксированный (определяется при объявлении)|Динамический (может расти/уменьшаться)|
|**Тип**|`[n]T` (например, `[3]int`)|`[]T` (например, `[]int`)|
|**Передача в функции**|Передается по значению (копируется)|Передается по ссылке (указатель)|
|**Инициализация**|`arr := [3]int{1, 2, 3}`|`slice := []int{1, 2, 3}`|
|**Гибкость**|Нет|Да (можно добавлять, удалять элементы)|

## Как устроен Slice?

### Какая стратегия его динамического расширения?

При добавлении элементов в срез через `append()`, если `len >= cap`, происходит **переаллокация**:

1. Создается новый массив с **удвоенной ёмкостью** (или больше, если нужно).
2. Все элементы копируются в новый массив.
3. Старый массив удаляется сборщиком мусора.

```go
slice := []int{1, 2, 3}
fmt.Println(cap(slice)) // 3

slice = append(slice, 4) 
fmt.Println(cap(slice)) // 6 (ёмкость удвоилась)
```

#### Правило увеличения ёмкости (для Go ≥1.18):

- При `cap < 256` → удвоение.
- При `cap ≥ 256` → увеличение на `25%`.

### Асимптотика работы со Slice?

| Операция                 | Асимптотика             | Комментарий                              |
| ------------------------ | ----------------------- | ---------------------------------------- |
| **Доступ по индексу**    | O(1)                    | Прямой доступ к элементу.                |
| **Добавление в конец**   | O(1) (амортизированная) | В среднем O(1) из-за стратегии удвоения. |
| **Вставка в середину**   | O(n)                    | Требуется сдвиг элементов.               |
| **Удаление из середины** | O(n)                    | Аналогично вставке.                      |
| **Поиск элемента**       | O(n)                    | Линейный поиск.                          |

- **Расширение среза** происходит с амортизированной сложностью O(1) благодаря удвоению ёмкости.
- **Операции вставки/удаления** имеют сложность O(n) из-за необходимости копирования данных.

#### Пример вставки

```go
slice := []int{1, 2, 3, 4}
// Вставка 10 на позицию 2 → O(n)
slice = append(slice[:2], append([]int{10}, slice[2:]...)...)
// Результат: [1, 2, 10, 3, 4]
```

## Примеры

#### Создание среза с заданной ёмкостью

```go
slice := make([]int, 3, 5) // len=3, cap=5
slice[0], slice[1], slice[2] = 1, 2, 3
slice = append(slice, 4)   // len=4, cap=5
```

#### Срезы как "окна" в массив

```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4]          // [2, 3, 4]
slice[0] = 20              // arr теперь [1, 20, 3, 4, 5]
```

#### Полное копирование среза

```go
src := []int{1, 2, 3}
dst := make([]int, len(src))
copy(dst, src)            // Копирует все элементы
```

## Рекомендации

- Указывайте явно ёмкость в `make([]T, len, cap)` для предварительного выделения памяти.
- Для частых вставок/удалений рассмотрите другие структуры данных (например, связанный список).

## Негативные кейсы

#### Что будет, если я буду писать/читать в/из nil Slice?

| **Операция**        | **nil Slice**                         |
| ------------------- | ------------------------------------- |
| **Запись**          | Паника (индекс) / `append()` работает |
| **Чтение**          | Паника (индекс)                       |
| **Проверка на nil** | `s == nil` → `true`                   |
| **Использование**   | Используйте `append()`                |

Используйте `append()`, если не уверены в инициализации.

##### Запись по индексу в nil Slice

Попытка записи в nil-срез вызывает **панику** (выход за границы):

```go
var s []int
s[0] = 1 // panic: runtime error: index out of range [0] with length 0
```


##### Чтение из nil Slice

Чтение из nil-среза также вызывает **панику**:

```go
var s []int
fmt.Println(s[0]) // panic: runtime error: index out of range [0] with length 0
```

##### Использование append() с nil Slice

Функция `append()` работает с nil-срезом и создает новый срез:

```go
var s []int
s = append(s, 1) // Создается новый срез [1]
fmt.Println(s)    // [1]
```

##### Nil Slice vs Empty Slice

**Nil Slice:**

```go
var s []int        // s == nil → true
fmt.Println(len(s)) // 0
```

**Empty Slice**:

```go
s := []int{}       // s == nil → false
fmt.Println(len(s)) // 0
```


**Особенности**:

- Оба имеют длину 0.
- `append()` работает одинаково для обоих.
- Nil-срез можно использовать в циклах (`for range`), но он не итерируется.

### Как сделать из Slice массив и зачем это нужно?

#### Примеры

##### Копирование в новый массив (безопасный метод)

```go
slice := []int{1, 2, 3, 4, 5}

// Создаем массив нужного размера и копируем данные
var arr [5]int
copy(arr[:], slice)  // Копируем элементы среза в массив

fmt.Println(arr)  // [1 2 3 4 5]
```

##### Приведение типа (только для Go 1.17+)

Начиная с Go 1.17, можно использовать **явное приведение типа**, если длина среза совпадает с размером массива:

```go
slice := []int{1, 2, 3, 4, 5}
arr := *(*[5]int)(slice)  // Приводим срез к указателю на массив, затем разыменовываем

fmt.Println(arr)  // [1 2 3 4 5]
```

**Важно**: Если длина среза меньше размера массива — будет **panic**.

#### Зачем это нужно?

Можно использовать как ключ в map.

#### Обратное преобразование (массив → срез)

Чтобы передать массив в функцию, ожидающую срез, используйте `arr[:]`:

```go
arr := [3]int{1, 2, 3}
slice := arr[:]  // Преобразуем массив в срез

fmt.Println(slice)  // [1 2 3]
```


