
# Что такое Garbage collector (сборщик мусора)

GC (garbage collector) в Go — это компонент рантайма, который **автоматически освобождает память**, занятую объектами, на которые **уже нет ссылок** (т.е. они больше не нужны программе).

Благодаря GC, мы не обязаны вручную управлять памятью (в отличие от C/C++), и не рискуем "забыть освободить" или освободить дважды.


Он следит за тем, чтобы:
- не было утечек памяти (memory leaks)
- память, которая больше не используется, освобождалась автоматически
- программа не крашилась от `malloc` ошибок

| Что делает                                | Как работает                                           |
| ----------------------------------------- | ------------------------------------------------------ |
| Освобождает память                        | Находит "мёртвые" объекты, которые больше не достижимы |
| Сканирует heap (кучу)                     | От корней (stack, globals) — по указателям             |
| Освобождает неиспользуемые объекты        | После завершения сканирования                          |
| Работает **конкурентно и инкрементально** | Чтобы не стопорить всю программу                       |

Он **не отвечает за исполнение кода** — только за управление памятью.

## Как работает

GC в Go — это **инкрементальный, конкурентный, нет-сопротивляющийся (non-moving)** сборщик, реализующий **алгоритм tri-color mark-and-sweep**, но финальные шаги требуют короткого стопа мира.

### Основные этапы работы

#### 1. Mark Start (STW - Stop the World)

- GC стартует с **короткой паузы**: программа **останавливается** (`stop-the-world`)
- Все goroutine приостанавливаются
- Отмечаются "корни" (стек goroutine, глобальные переменные)
- Начинается **маркировка** (marking)

#### 2. Concurrent Mark

- Программа продолжает работать ✅
- GC **параллельно с приложением** сканирует кучу (heap)
	- фоновая горутина обходит все **достижимые объекты**.
- Используется **трицветный алгоритм**:
    - Серый (gray) — объекты, которые нужно ещё просканировать
    - Чёрный (black) — живые объекты
    - Белый (white) — кандидаты на удаление
- Пишущие операции (write barrier) отслеживают изменения в указателях

#### 3. Mark Termination (STW #2)

- Ещё одна **очень короткая stop-the-world-пауза**
- Финализируется маркировка
	- Завершить маркировку
	- Обновить состояния
- Убедиться, что ничего не пропущено

#### 4. **Sweep**

- GC очищает белые (неиспользуемые) объекты из памяти 
- Это происходит **асинхронно** — в фоне
- Память возвращается в пул, но не всегда ОС

#### Упрощённая визуализация

```go
          ┌─────────────┐
          │ Mark Start  │ (STW)
          └────┬────────┘
               ↓
     ┌────────────────────┐
     │ Concurrent Marking │ (параллельно)
     └────┬───────────────┘
          ↓
 ┌─────────────────────────────────┐
 │ Mark Termination (короткий STW) │
 └────┬────────────────────────────┘
      ↓
     ┌─────────┐
     │ Sweep   │ (в фоне)
     └─────────┘
```

|Фаза|Стоп-мир?|Что происходит|
|---|---|---|
|**Start GC**|✅ Коротко|Перевод всех корней в серый цвет|
|**Mark**|❌ Нет|Обход живых объектов — GC идёт "по ссылкам"|
|**STW for mark end**|✅ Коротко|Завершаем маркировку, дожидаемся завершения|
|**Sweep**|❌ Нет|Очищаем мёртвые объекты, параллельно с кодом|
GC **никогда не блокирует программу целиком надолго**, только **короткие паузы** в начале и в конце маркировки.

### Инкрементальный и конкурентный режим

#### Что означает "инкрементальный"

**Инкрементальный GC** = **разделяет работу на маленькие кусочки**, которые выполняются **поэтапно**, а не за один большой "стоп мир".

##### Пример

Вместо того чтобы останавливать всю программу на 200 мс и чистить всё сразу, GC делает **немного работы каждые N миллисекунд** (например, между goroutine), чтобы **не мешать основному коду**.

##### Плюсы

- Нет больших задержек (low latency)
- Лучше для real-time и серверных приложений

#### Что значит "конкурентный"?

**Конкурентный GC** = работает **параллельно с основным кодом** (mutator'ом).

- Go-программа продолжает работать и выделять память, **пока GC уже ищет мусор** в фоне.
- Это достигается благодаря **фонам маркерам (background marker)**, которые анализируют граф объектов **без полной остановки всех `goroutine`**.

### Что за "tri-color"?

GC использует **модель окраски объектов**:

| Цвет      | Значение                                      |
| --------- | --------------------------------------------- |
| ⚪️ Белый  | Объект ещё не просмотрен (возможно мусор)     |
| ⚫️ Чёрный | Объект просмотрен, точно жив                  |
| ⚪️ Серый  | Объект найден, но его "дети" ещё не проверены |

GC начинает с корней (глобальных переменных и стеков) и **рекурсивно обходит ссылки**, пока не покроет весь живой граф. Всё, что осталось белым — удаляется.

## Какие **алгоритмы и правила** заложены в GC Go?

### Mark-and-sweep

- Стандартный алгоритм:
    - `mark` — ищем живые объекты
    - `sweep` — удаляем мусор

### Tri-color invariant

- Используется для безопасной конкурентной маркировки
- Не допускается: белый → чёрный **минуя серый**
- Чтобы это соблюдалось, Go использует **write barriers** (спец-код, срабатывающий при записи ссылки)

### Incremental & concurrent

- GC работает **по кусочкам**
- Бóльшая часть времени — в фоне, не блокируя программу
- Только две короткие паузы (STW) — в начале и в конце маркировки

### **Non-moving GC**

- Объекты **не перемещаются в памяти** (в отличие от Java/GoGC версии поколений)
- Это упрощает взаимодействие с C через `cgo` и нативный доступ к указателям

### Generational heuristics _(но не полноценный generational GC)_

- Учитываются **возраст объектов**
- Новые объекты проверяются активнее
- Но **молодые/старые поколения в отдельные регионы не выделяются**

### **Work stealing** и параллельные маркеры

- Несколько потоков (`P`) участвуют в маркировке объектов
- Используют стратегии типа work-stealing (воруем задачу из очереди другого потока)

## Как можно управлять GC?

Go не даёт ручного управления GC (в стиле `malloc/free`), но есть **механизмы настройки и контроля**:

### Управление через код

#### `runtime.GC()`

Принудительно запустить сборку мусора:

```go
import "runtime"
runtime.GC()
```

#### `runtime/debug.SetGCPercent(n int)`

Контроль **частоты GC**:

- `n = 100` (по умолчанию): новый GC запускается, когда heap увеличился на 100%
- `n = 200` — реже
- `n = 20` — чаще
- `n = -1` — **отключает автоматический GC** (⚠️ опасно!)

```go
import "runtime/debug"
debug.SetGCPercent(50) // запускается чаще
```

#### `GOGC` — переменная окружения

То же самое что и `runtime/debug.SetGCPercent(n int)`, но через переменную среды:

```go
GOGC=200 ./myapp  # GC будет запускаться реже
```

### Профилирование

#### `runtime.ReadMemStats(&stats)`

Позволяет собрать данные о работе GC:

```go
var stats runtime.MemStats
runtime.ReadMemStats(&stats)
fmt.Println("GC count:", stats.NumGC)
```

#### Профили

- `pprof/heap` — анализ использования памяти
- `pprof/goroutine` — живые goroutines

### Параметры настройки

`GOGC` — уровень агрессивности GC (default = 100):
- `200` = GC запускается, когда heap вырастает на 200%
- `off` = отключить GC
```bash
GOGC=off go run main.go
```
- `GODEBUG=gctrace=1` — логирует каждую GC-паузу

## Реальные цифры

- STW-паузы в Go обычно: **< 1 мс**
- Загрузка от GC контролируется переменной `GOGC` (по умолчанию 100 — означает "собирать, когда хип увеличится на 100%").

## Пример

### Логирование каждой GC-паузы

```go
func main() {
    for {
        _ = make([]byte, 10_000_000) // Постоянно выделяем память
    }
}
```

Если запустить с `GODEBUG=gctrace=1`, то увидим примерно такое:

```
gc 1 @0.004s 5%: 0.3+0.4+0.02 ms clock, 1.2+0.2/1.3/0.6+0.0 ms cpu, 4->4->2 MB, 5 MB goal, 8 P

```

Где:
- 0.3 — STW start
- 0.4 — background mark
- 0.02 — STW end

### Хороший пример чистки

Что происходит:

- Мы выделяем много памяти, но **ссылок на массивы больше нет** — они доступны для GC.
- `HeapAlloc` остаётся примерно одинаковым, потому что GC **очищает их сразу**.

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    for i := 0; i < 10; i++ {
        _ = make([]byte, 100_000_000) // 100MB
        runtime.GC() // вручную триггерим GC
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        fmt.Printf("After iteration %d: HeapAlloc = %d MB\n", i, m.HeapAlloc/1024/1024)
    }
}
```

### Не может очистить — потому что ссылка осталась

Что тут происходит:

- Мы **удерживаем слайс `chunk[:1]`**, но на самом деле это слайс на **всю ту же 100MB память**.
- GC думает: “Эй, ты ведь всё ещё используешь эту память”, и **не освобождает её**.
- В итоге: память не уменьшается, `HeapAlloc` растёт.

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    var holder [][]byte

    for i := 0; i < 10; i++ {
        chunk := make([]byte, 100_000_000) // 100MB
        holder = append(holder, chunk[:1]) // ❗️оставляем ссылку на часть
        runtime.GC()
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        fmt.Printf("After iteration %d: HeapAlloc = %d MB\n", i, m.HeapAlloc/1024/1024)
    }
}

// Output:
// After iteration 0: HeapAlloc = 95 MB
// After iteration 1: HeapAlloc = 191 MB
// After iteration 2: HeapAlloc = 286 MB
// After iteration 3: HeapAlloc = 381 MB
// After iteration 4: HeapAlloc = 477 MB
// After iteration 5: HeapAlloc = 572 MB
// After iteration 6: HeapAlloc = 667 MB
// After iteration 7: HeapAlloc = 763 MB
// After iteration 8: HeapAlloc = 858 MB
// After iteration 9: HeapAlloc = 954 MB
```

#### Фикс: "отцепляем" мусор

```go
holder = append(holder, append([]byte{}, chunk[:1]...)) // создаём копию 1 байта

// Output:
// After iteration 0: HeapAlloc = 0 MB
// After iteration 1: HeapAlloc = 0 MB
// After iteration 2: HeapAlloc = 0 MB
// After iteration 3: HeapAlloc = 0 MB
// After iteration 4: HeapAlloc = 0 MB
// After iteration 5: HeapAlloc = 0 MB
// After iteration 6: HeapAlloc = 0 MB
// After iteration 7: HeapAlloc = 0 MB
// After iteration 8: HeapAlloc = 0 MB
// After iteration 9: HeapAlloc = 0 MB
```

Теперь ссылка указывает **только на 1 байт**, и 100MB **становится доступной для GC**.

# Что такое **Stop-the-World (STW)**?

**Stop-the-World (STW)** — это фаза, когда **планировщик Go останавливает все работающие goroutine**, чтобы выполнить **системные задачи рантайма**. Во время этой паузы **не выполняется ни одна горутина**.

STW-паузы в Go обычно: **< 1 мс**

## Когда происходит STW?

1. **Сборка мусора (GC)** — во время фаз **маркировки** или **очистки**.
2. **Перевод `G` между `M`/`P`** — для обновления состояния, как часть preemption.
3. **Старт/стоп профайлера, трассировки или дебаг-инструментов**.
4. **Разделение стека goroutine (stack growth/shrink)**.
    
Go старается **минимизировать длительность STW**, особенно в GC — он работает в **инкрементальном и конкурентном режиме**, но финальные шаги требуют короткого стопа мира.
