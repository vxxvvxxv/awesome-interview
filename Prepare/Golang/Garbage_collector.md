
# Что такое Garbage collector (сборщик мусора)

GC (garbage collector) в Go — это компонент рантайма, который **автоматически освобождает память**, занятую объектами, на которые **уже нет ссылок** (т.е. они больше не нужны программе).

Благодаря GC, мы не обязаны вручную управлять памятью (в отличие от C/C++), и не рискуем "забыть освободить" или освободить дважды.


Он следит за тем, чтобы:
- не было утечек памяти (memory leaks)
- память, которая больше не используется, освобождалась автоматически
- программа не крашилась от `malloc` ошибок

| Что делает                                | Как работает                                           |
| ----------------------------------------- | ------------------------------------------------------ |
| Освобождает память                        | Находит "мёртвые" объекты, которые больше не достижимы |
| Сканирует heap (кучу)                     | От корней (stack, globals) — по указателям             |
| Освобождает неиспользуемые объекты        | После завершения сканирования                          |
| Работает **конкурентно и инкрементально** | Чтобы не стопорить всю программу                       |

Он **не отвечает за исполнение кода** — только за управление памятью.

## Как работает

GC в Go — это **инкрементальный, конкурентный, нет-сопротивляющийся (non-moving)** сборщик, реализующий **алгоритм tri-color mark-and-sweep**, но финальные шаги требуют короткого стопа мира.

### Основные этапы работы

#### 1. Mark Start (STW - Stop the World)

- GC стартует с **короткой паузы**: программа **останавливается** (`stop-the-world`)
- Все goroutine приостанавливаются
- Отмечаются "корни" (стек goroutine, глобальные переменные)
- Начинается **маркировка** (marking)

#### 2. Concurrent Mark

- Программа продолжает работать ✅
- GC **параллельно с приложением** сканирует кучу (heap)
	- фоновая горутина обходит все **достижимые объекты**.
- Используется **трицветный алгоритм**:
    - Серый (gray) — объекты, которые нужно ещё просканировать
    - Чёрный (black) — живые объекты
    - Белый (white) — кандидаты на удаление
- Пишущие операции (write barrier) отслеживают изменения в указателях

#### 3. Mark Termination (STW #2)

- Ещё одна **очень короткая stop-the-world-пауза**
- Финализируется маркировка
	- Завершить маркировку
	- Обновить состояния
- Убедиться, что ничего не пропущено

#### 4. **Sweep**

- GC очищает белые (неиспользуемые) объекты из памяти 
- Это происходит **асинхронно** — в фоне
- Память возвращается в пул, но не всегда ОС

#### Упрощённая визуализация

```go
          ┌─────────────┐
          │ Mark Start  │ (STW)
          └────┬────────┘
               ↓
     ┌────────────────────┐
     │ Concurrent Marking │ (параллельно)
     └────┬───────────────┘
          ↓
 ┌─────────────────────────────────┐
 │ Mark Termination (короткий STW) │
 └────┬────────────────────────────┘
      ↓
     ┌─────────┐
     │ Sweep   │ (в фоне)
     └─────────┘
```

|Фаза|Стоп-мир?|Что происходит|
|---|---|---|
|**Start GC**|✅ Коротко|Перевод всех корней в серый цвет|
|**Mark**|❌ Нет|Обход живых объектов — GC идёт "по ссылкам"|
|**STW for mark end**|✅ Коротко|Завершаем маркировку, дожидаемся завершения|
|**Sweep**|❌ Нет|Очищаем мёртвые объекты, параллельно с кодом|
GC **никогда не блокирует программу целиком надолго**, только **короткие паузы** в начале и в конце маркировки.

### Инкрементальный и конкурентный режим

#### Что означает "инкрементальный"

**Инкрементальный GC** = **разделяет работу на маленькие кусочки**, которые выполняются **поэтапно**, а не за один большой "стоп мир".

##### Пример

Вместо того чтобы останавливать всю программу на 200 мс и чистить всё сразу, GC делает **немного работы каждые N миллисекунд** (например, между goroutine), чтобы **не мешать основному коду**.

##### Плюсы

- Нет больших задержек (low latency)
- Лучше для real-time и серверных приложений

#### Что значит "конкурентный"?

**Конкурентный GC** = работает **параллельно с основным кодом** (mutator'ом).

- Go-программа продолжает работать и выделять память, **пока GC уже ищет мусор** в фоне.
- Это достигается благодаря **фонам маркерам (background marker)**, которые анализируют граф объектов **без полной остановки всех `goroutine`**.

### Что за "tri-color"?

GC использует **модель окраски объектов**:

| Цвет      | Значение                                      |
| --------- | --------------------------------------------- |
| ⚪️ Белый  | Объект ещё не просмотрен (возможно мусор)     |
| ⚫️ Чёрный | Объект просмотрен, точно жив                  |
| ⚪️ Серый  | Объект найден, но его "дети" ещё не проверены |

GC начинает с корней (глобальных переменных и стеков) и **рекурсивно обходит ссылки**, пока не покроет весь живой граф. Всё, что осталось белым — удаляется.

## Какие **алгоритмы и правила** заложены в GC Go?

### Mark-and-sweep

- Стандартный алгоритм:
    - `mark` — ищем живые объекты
    - `sweep` — удаляем мусор

### Tri-color invariant

- Используется для безопасной конкурентной маркировки
- Не допускается: белый → чёрный **минуя серый**
- Чтобы это соблюдалось, Go использует **write barriers** (спец-код, срабатывающий при записи ссылки)

### Incremental & concurrent

- GC работает **по кусочкам**
- Бóльшая часть времени — в фоне, не блокируя программу
- Только две короткие паузы (STW) — в начале и в конце маркировки

### **Non-moving GC**

- Объекты **не перемещаются в памяти** (в отличие от Java/GoGC версии поколений)
- Это упрощает взаимодействие с C через `cgo` и нативный доступ к указателям

### Generational heuristics _(но не полноценный generational GC)_

- Учитываются **возраст объектов**
- Новые объекты проверяются активнее
- Но **молодые/старые поколения в отдельные регионы не выделяются**

### **Work stealing** и параллельные маркеры

- Несколько потоков (`P`) участвуют в маркировке объектов
- Используют стратегии типа work-stealing (воруем задачу из очереди другого потока)

## Как можно управлять GC?

Go не даёт ручного управления GC (в стиле `malloc/free`), но есть **механизмы настройки и контроля**:

### Управление через код

#### `runtime.GC()`

Принудительно запустить сборку мусора:

```go
import "runtime"
runtime.GC()
```

#### `runtime/debug.SetGCPercent(n int)`

Контроль **частоты GC**:

- `n = 100` (по умолчанию): новый GC запускается, когда heap увеличился на 100%
- `n = 200` — реже
- `n = 20` — чаще
- `n = -1` — **отключает автоматический GC** (⚠️ опасно!)

```go
import "runtime/debug"
debug.SetGCPercent(50) // запускается чаще
```

#### `GOGC` — переменная окружения

То же самое что и `runtime/debug.SetGCPercent(n int)`, но через переменную среды:

```go
GOGC=200 ./myapp  # GC будет запускаться реже
```

### Профилирование

#### `runtime.ReadMemStats(&stats)`

Позволяет собрать данные о работе GC:

```go
var stats runtime.MemStats
runtime.ReadMemStats(&stats)
fmt.Println("GC count:", stats.NumGC)
```

#### Профили

- `pprof/heap` — анализ использования памяти
- `pprof/goroutine` — живые goroutines

### Параметры настройки

`GOGC` — уровень агрессивности GC (default = 100):
- `200` = GC запускается, когда heap вырастает на 200%
- `off` = отключить GC
```bash
GOGC=off go run main.go
```
- `GODEBUG=gctrace=1` — логирует каждую GC-паузу

## Реальные цифры

- STW-паузы в Go обычно: **< 1 мс**
- Загрузка от GC контролируется переменной `GOGC` (по умолчанию 100 — означает "собирать, когда хип увеличится на 100%").

## Пример

### Логирование каждой GC-паузы

```go
func main() {
    for {
        _ = make([]byte, 10_000_000) // Постоянно выделяем память
    }
}
```

Если запустить с `GODEBUG=gctrace=1`, то увидим примерно такое:

```
gc 1 @0.004s 5%: 0.3+0.4+0.02 ms clock, 1.2+0.2/1.3/0.6+0.0 ms cpu, 4->4->2 MB, 5 MB goal, 8 P

```

Где:
- 0.3 — STW start
- 0.4 — background mark
- 0.02 — STW end

### Хороший пример чистки

Что происходит:

- Мы выделяем много памяти, но **ссылок на массивы больше нет** — они доступны для GC.
- `HeapAlloc` остаётся примерно одинаковым, потому что GC **очищает их сразу**.

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    for i := 0; i < 10; i++ {
        _ = make([]byte, 100_000_000) // 100MB
        runtime.GC() // вручную триггерим GC
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        fmt.Printf("After iteration %d: HeapAlloc = %d MB\n", i, m.HeapAlloc/1024/1024)
    }
}
```

### Не может очистить — потому что ссылка осталась

Что тут происходит:

- Мы **удерживаем слайс `chunk[:1]`**, но на самом деле это слайс на **всю ту же 100MB память**.
- GC думает: “Эй, ты ведь всё ещё используешь эту память”, и **не освобождает её**.
- В итоге: память не уменьшается, `HeapAlloc` растёт.

```go
package main

import (
    "fmt"
    "runtime"
)

func main() {
    var holder [][]byte

    for i := 0; i < 10; i++ {
        chunk := make([]byte, 100_000_000) // 100MB
        holder = append(holder, chunk[:1]) // ❗️оставляем ссылку на часть
        runtime.GC()
        var m runtime.MemStats
        runtime.ReadMemStats(&m)
        fmt.Printf("After iteration %d: HeapAlloc = %d MB\n", i, m.HeapAlloc/1024/1024)
    }
}

// Output:
// After iteration 0: HeapAlloc = 95 MB
// After iteration 1: HeapAlloc = 191 MB
// After iteration 2: HeapAlloc = 286 MB
// After iteration 3: HeapAlloc = 381 MB
// After iteration 4: HeapAlloc = 477 MB
// After iteration 5: HeapAlloc = 572 MB
// After iteration 6: HeapAlloc = 667 MB
// After iteration 7: HeapAlloc = 763 MB
// After iteration 8: HeapAlloc = 858 MB
// After iteration 9: HeapAlloc = 954 MB
```

#### Фикс: "отцепляем" мусор

```go
holder = append(holder, append([]byte{}, chunk[:1]...)) // создаём копию 1 байта

// Output:
// After iteration 0: HeapAlloc = 0 MB
// After iteration 1: HeapAlloc = 0 MB
// After iteration 2: HeapAlloc = 0 MB
// After iteration 3: HeapAlloc = 0 MB
// After iteration 4: HeapAlloc = 0 MB
// After iteration 5: HeapAlloc = 0 MB
// After iteration 6: HeapAlloc = 0 MB
// After iteration 7: HeapAlloc = 0 MB
// After iteration 8: HeapAlloc = 0 MB
// After iteration 9: HeapAlloc = 0 MB
```

Теперь ссылка указывает **только на 1 байт**, и 100MB **становится доступной для GC**.

# Green Tea GC (Go 1.26)

> Источники: [Go Blog — The Green Tea Garbage Collector](https://go.dev/blog/greenteagc) · [Issue #73581](https://github.com/golang/go/issues/73581) · [InfoWorld](https://www.infoworld.com/article/4131097/go-1-26-unleashes-performance-boosting-green-tea-gc.html)

## Проблема классического GC

Классический tri-color GC в Go обходит объекты **индивидуально** — как граф, где объекты это вершины, а указатели — рёбра. Этот подход игнорирует физическое расположение объектов в памяти:

- **Плохая пространственная локальность**: GC прыгает между разными частями памяти.
- **Плохая временная локальность**: одна и та же область памяти перечитывается многократно.
- **~35% времени маркировки** тратится на ожидание данных из RAM (cache misses).

```
Старый GC: объект A → объект B (разные регионы памяти) → объект C → ...
           ↑ cache miss ↑                               ↑ cache miss ↑
```

> ~90% стоимости GC — это маркировка (marking), только ~10% — очистка (sweep).

## Идея Green Tea: сканирование спанами

**Ключевая идея**: вместо очереди отдельных объектов GC ставит в очередь **спаны** — непрерывные блоки памяти по **8 KiB**.

Спан (span) — единица управления памятью в Go runtime:
- Содержит объекты **одного size class**.
- Например, спан с size class 32 байта разделён на слоты по 32 байта.
- Из адреса объекта можно вычислить его метаданные простой арифметикой.

```
Старый GC:  [obj_A] → [obj_B] → [obj_C] → [obj_D]   ← случайные адреса
Green Tea:  [span 8 KiB: A, B, C, D, E, F, G, H]    ← всё в одном регионе
```

## Трёхцветный инвариант на уровне спана

Классические white/gray/black теперь хранятся **внутри спана** — два бита на объект:

| gray bit | black bit | Состояние |
|----------|-----------|-----------|
| 0        | 0         | White (не обнаружен) |
| 1        | 0         | Gray (найден, нужно сканировать) |
| 1        | 1         | Black (отсканирован) |

**Алгоритм:**
1. GC находит указатель на малый объект → устанавливает его **gray bit** в спане.
2. Если спан ещё не в очереди — **весь спан** ставится в очередь (не отдельный объект).
3. Воркер берёт спан, находит все gray-but-not-black объекты, сканирует их, выставляет black.

## Оптимизация одиночного объекта (Hit Flag)

Если в спане только один живой объект — сканировать весь спан расточительно:

```
Спан: [obj_A: gray] [пусто] [пусто] [пусто] ... [пусто]
```

Green Tea вводит **hit flag**:
- При первой маркировке объекта — он становится **"представителем"** спана.
- Если другой объект в том же спане тоже маркируется — hit flag = true.
- При сканировании спана:
  - `hit_flag == true` → сканируем весь спан (максимальная локальность).
  - `hit_flag == false` → сканируем только представителя (экономим работу).

## Work Stealing для балансировки нагрузки

У каждого GC-воркера своя **локальная очередь спанов**. Простаивающий воркер крадёт задачи из очереди других воркеров:

```
Worker 1: [span_A] [span_B] [span_C] ←── Worker 2 крадёт span_C
Worker 2: []  ← пуст, берёт из очереди W1
```

Это устраняет узкое место глобального списка и повышает масштабируемость по CPU-ядрам.

## SIMD-ускорение (amd64)

На amd64 с AVX/AVX-512 Green Tea использует векторные инструкции для обработки битовых масок спана:

```
1. Загрузить seen_bits и scanned_bits для всей страницы
2. Union (OR)  → новые scanned_bits
3. XOR         → active_objects_bitmap (что нужно отсканировать)
4. Expand bits → one bit per 8-byte word (для быстрого обхода)
```

Это позволяет за одну инструкцию обработать 8–16 объектов сразу.

## Производительность

| Метрика | Результат |
|---------|-----------|
| GC CPU overhead (микробенчмарки) | **-10…-50%** |
| GC CPU overhead (реальные приложения) | **-10…-40%** |
| L1/L2 cache misses | **-50%** |
| Дополнительное ускорение на Ice Lake / Zen 4+ | ещё **-10%** |

**Кому полезнее всего:**
- Сервисы с деревьями, графами, кэшами (высокий fan-out heap).
- Приложения, где GC > 10% CPU.
- Многоядерные серверы.

**Ограничения:**
- Не создаёт локальность там, где её нет в данных.
- Low-fanout workloads (мало указателей, мало объектов) — выигрыш минимален.

## Сравнение: Old GC vs Green Tea GC

| Характеристика | Старый GC | Green Tea GC |
|----------------|-----------|-------------|
| Единица сканирования | Отдельный объект | Спан 8 KiB |
| Фокус | Все размеры объектов | Малые объекты (≤ 512 байт) |
| Пространственная локальность | Плохая | Высокая |
| Временная локальность | Плохая | Высокая |
| Очередь работы | Глобальный список | Локальные очереди + work stealing |
| SIMD | Нет | Да (amd64, AVX-512) |
| Масштабируемость по CPU | Ограниченная | Линейная |
| Снижение GC overhead | Базовая | 10–50% |
| Промахи кэша | Базовые | -50% |

## Управление (Go 1.26)

Green Tea **включён по умолчанию** в Go 1.26.

```bash
# Отключить (до Go 1.27)
GOEXPERIMENT=nogreenteagc go build .
```

В Go 1.25 был доступен как эксперимент:
```bash
GOEXPERIMENT=greenteagc go build .
```

## Схема работы Green Tea

```
Heap
├── Span A [8 KiB, size=32B]
│   ├── [obj1: black] [obj2: gray] [obj3: white] [obj4: gray] ...
│   └── В очереди воркера → сканируем obj2, obj4 за один проход
│
├── Span B [8 KiB, size=64B]
│   └── Нет серых объектов → пропускаем
│
└── Span C [8 KiB, size=16B]
    └── Только 1 серый (hit_flag=false) → сканируем только его
```

---

# Что такое **Stop-the-World (STW)**?

**Stop-the-World (STW)** — это фаза, когда **планировщик Go останавливает все работающие goroutine**, чтобы выполнить **системные задачи рантайма**. Во время этой паузы **не выполняется ни одна горутина**.

STW-паузы в Go обычно: **< 1 мс**

## Когда происходит STW?

1. **Сборка мусора (GC)** — во время фаз **маркировки** или **очистки**.
2. **Перевод `G` между `M`/`P`** — для обновления состояния, как часть preemption.
3. **Старт/стоп профайлера, трассировки или дебаг-инструментов**.
4. **Разделение стека goroutine (stack growth/shrink)**.
    
Go старается **минимизировать длительность STW**, особенно в GC — он работает в **инкрементальном и конкурентном режиме**, но финальные шаги требуют короткого стопа мира.
