Полезные ссылки:
- [Как на самом деле устроен тип Map в Golang? | Golang под капотом](https://www.youtube.com/watch?v=P_SXTUiA-9Y)
- [Faster Go maps with Swiss Tables — go.dev/blog](https://go.dev/blog/swisstable)
- [How Go 1.24's Swiss Tables saved us hundreds of gigabytes — Datadog](https://www.datadoghq.com/blog/engineering/go-swiss-tables/)
- [Source code: swiss map](https://github.com/golang/go/blob/master/src/runtime/map_swiss.go)
- [Source code: old map](https://github.com/golang/go/blob/master/src/runtime/map_noswiss.go)

---

**Хеш-мапа** — это структура данных, которая хранит пары **ключ-значение** и обеспечивает:

- Быстрый доступ к значению по ключу (`O(1)` в среднем).
- Динамическое расширение при увеличении количества элементов.

**Аналогия из жизни**:  
Представьте словарь, где слова (ключи) сразу ведут к их определениям (значениям), минуя перелистывание страниц.

#### Почему хэш-мапы эффективны?

- **Равномерное распределение**: Хорошая хэш-функция минимизирует коллизии.
- **Амортизированная сложность `O(1)`**: Большинство операций выполняются за константное время.
- **Динамическое масштабирование**: Мапа адаптируется под нагрузку.

## Что такое Hash-таблица?

**Хеш-таблица** — это массив (обычно динамический), где:

- Каждый элемент (бакет) хранит **список пар ключ-значение**.
- **Индекс бакета** вычисляется как `hash(key) % len(buckets)`.

```go
Ключ: "Alice"  →  Хеш: 0x3A7  →  Индекс бакета: 0x3A7 % 8 = 7
```

## Что такое Hash-функция?

**Хэш-функция** — это алгоритм, который преобразует ключ в числовой индекс (хеш), указывающий на ячейку (бакет) внутри массива. 

**Свойства хорошей хэш-функции**:

1. **Детерминированность**: Один и тот же ключ всегда дает одинаковый хеш.    
2. **Равномерное распределение**: Ключи равномерно распределяются по бакетам.
3. **Быстрота вычислений**: Хеш считается быстро даже для больших данных.

#### Пример

Ключ `"Alice"` → Хэш-функция → Индекс `3` → Бакет 3.

## Что такое Hash-коллизия?

**Коллизия** — это ситуация, когда два разных ключа дают **одинаковый хеш** (или одинаковый индекс бакета).

```go
"Alice" → hash = 0x3A7 → индекс = 7
"Bob"   → hash = 0x1A7 → индекс = 7  // Коллизия!
```

**Коллизии** замедляют операции, но хорошая хеш-функция минимизирует их.

#### Какие способы по решению коллизий?

| Метод                                    | Описание                                                                    | Плюсы и минусы                         |
| ---------------------------------------- | --------------------------------------------------------------------------- | -------------------------------------- |
| **Chaining** (цепочки)                   | Переполненные ключи хранятся в связанных бакетах (как в Go).                | Простота, но возможны длинные цепочки. |
| **Open Addressing** (открытая адресация) | Ключи ищутся в других бакетах по алгоритму (линейный/квадратичный пробинг). | Лучше для кэша, но сложнее удаление.   |

##### Цепочки (Chaining)

Элементы с одинаковым хешом хранятся в виде связанного списка внутри бакета (как в Go).

```go
Бакет 1: ["Alice", 25] → ["Bob", 30]
```

##### Открытая адресация (Open Addressing)

При коллизии ищется следующий свободный бакет (например, линейный пробинг).

## Шаги работы Hash-мапы

1. **Вычисление хеша**:
	1. Ключ обрабатывается хэш-функцией, которая возвращает число (например, `hash("Alice") = 12345`).
2. **Определение бакета**:
	2. Индекс бакета вычисляется как `hash % количество_бакетов` (например, `12345 % 8 = 1` → бакет 1).
3. **Разрешение коллизий**:  
	1. Если в бакете уже есть элементы, используется метод **цепочки** (в Go) — элементы хранятся в виде связанного списка.
4. **Сохранение/поиск значения**:
	2. Ключ и значение сохраняются в бакете. При поиске ключ сравнивается с сохраненными ключами в бакете.

## Как устроена Map в Go?

- [Мапы в Go: уровень Pro](https://habr.com/ru/companies/avito/articles/774618/
- [Source code: old map](https://github.com/golang/go/blob/master/src/runtime/map_noswiss.go)
- [Source code: swiss map](https://github.com/golang/go/blob/master/src/runtime/map_swiss.go)
- Benchmarks 

**Мапа в Go** — это хеш-таблица с цепочками для разрешения коллизий и состоящая из:

- **`hmap`**: Основная структура с метаданными (количество элементов, бакеты и т.д.).    
- **`bmap` (бакеты)**: Каждый бакет хранит до 8 пар ключ-значение и ссылку на следующий бакет при коллизиях.

```go
// Заголовок для Go map.
type hmap struct {
    count     int        // Количество элементов
    B         uint8      // Логарифм числа бакетов (2^B)
    hash0     uint32     // hash seed    

    buckets   unsafe.Pointer // Указатель на массив 2^B бакетов, может быть nil, если count == 0.
	oldbuckets unsafe.Pointer // предыдущий массив бакетов половинного размера, не nil только тогда, когда было увеличение
	
// ... другие поля
}

type bmap struct {
    tophash  [8]uint8    // Первые 8 бит хешей ключей
    keys     [8]keyType  // Ключи
    values   [8]valueType// Значения
    overflow *bmap       // Ссылка на следующий бакет при коллизиях
}
```

### Схема
```go

-----------------------
| MAP                 |
|                     |
|   [LEN] [*Buckets]  |
|              |      |
---------------+-------
               |
               |
---------------+-----------
| Buckets                 |
|                         |
| [LOBHash]     [LOBHash] |
| [Bucket ]     [Bucket ] |
|    |                    |
-----+---------------------
     |
     |
-----+-------------------------
| [E1] ... [E5] [_] [_] [_]   |
|------------------------------
| [Key] [Key] [_] [Val] [Val] |
-------------------------------

```

### Асимптотика работы с мапой в Go

| Операция      | Средний случай | Худший случай (при коллизиях)          |
| ------------- | -------------- | -------------------------------------- |
| `map[key]`    | `O(1)`         | `O(n)` (если все ключи в одном бакете) |
| `map[key] =`  | `O(1)`         | `O(n)` (рехеширование)                 |
| `delete(key)` | `O(1)`         | `O(n)` (при рехешировании)             |

## Что такое Load-factor?

**Коэффициент заполняемости таблицы**, или **load factor** — это отношение количества хранимых пар «ключ-значение» к размеру таблицы. 

Формула:

```c
LF = количество_элементов / количество_бакетов
```

Если они достигают пограничного значения, то хэш-мапу расширяют, а индексы пар пересчитывают и перераспределяют.

- **По умолчанию в Go** мапа расширяется при `LF ≈ 6.5`.
- Высокий LF увеличивает вероятность коллизий.

## Как происходит реиндексация/рехеширование?

**Рехеширование** происходит при `Load Factor ≈ 6.5`.

При достижении `Load Factor` мапа в Go **расширяется в 2 раза**:

1. Создается новый массив бакетов (`len(newBuckets) = 2 * len(oldBuckets)`).    
2. Все ключи **перехешируются** и распределяются по новым бакетам.
3. Переход на новые бакеты происходит **постепенно** (при следующих операциях с мапой), чтобы избежать резких задержек.
    
**Совет**: Если известен размер мапы, инициализируйте её через `make(map[K]V, size)` для избежания лишних рехеширований.

### Псевдокод рехеширования

```go
func (h *hmap) grow() {
    newBuckets := make([]bmap, 2 * len(h.buckets))
    for bucket := range h.buckets {
        for key, val := range bucket {
            newHash := hash(key) % len(newBuckets)
            newBuckets[newHash].add(key, val)
        }
    }
    h.buckets = newBuckets
}
```

### Негативные кейсы

#### Что будет, если я буду писать/читать в/из nil Map?

| **Операция**        | **nil Map**                 |
| ------------------- | --------------------------- |
| **Запись**          | Паника (`panic`)            |
| **Чтение**          | Возвращает нулевое значение |
| **Проверка на nil** | `m == nil` → `true`         |
| **Использование**   | Только чтение (без паники)  |
Всегда инициализируйте мапы через `make()` или литерал:

```go
m := make(map[string]int) // или m := map[string]int{}
```

###### Запись в nil Map

Попытка записи в nil-мапу вызывает **панику** (panic):

```go
var m map[string]int
m["key"] = 42 // panic: assignment to entry in nil map
```

##### Чтение из nil Map

Чтение из nil-мапы **не вызывает паники** и возвращает нулевое значение типа:

```go
var m map[string]int
fmt.Println(m["key"]) // 0 (нулевое значение для int)
```

Для nil-мапы проверка через `, ok` всегда возвращает `false`:

```go
var m map[string]int
value, ok := m["key"]
fmt.Println(ok) // false
```

## Что может быть ключом в Map Go?

В Go ключом в `map` может быть **любой тип, для которого определено сравнение на равенство (`==`)**.  

Это включает:
- Все **встроенные скалярные типы** (кроме `slice`, `map`, `func` — они **не поддерживаются**).
- **Структуры** (если все их поля сравнимы).
- **Указатели** (сравниваются по адресу).
- **Каналы** (сравниваются по ссылке).
- **Интерфейсы** (если их динамические значения сравнимы).

**Пример - Интерфейсы (если динамическое значение сравнимо)**

```go
var (
    a interface{} = "hello"
    b interface{} = 42
)

m8 := map[interface{}]string{
    a: "string value",
    b: "int value",
}
```

### Что НЕ может быть ключом?

Типы, **не поддерживающие `==`**:

- **Срезы (`[]int`, `[]string`)**. `invalid map key type []int`
- **Функции (`func()`)**. `invalid map key type func()`
- **Мапы (`map[string]int`)**. `invalid map key type map[string]int`

### Может ли `nil` быть ключом в мапе?

**Да, может**, но с оговорками.

- **Для указателей, каналов, интерфейсов, функций, срезов и мап** `nil` — это валидное нулевое значение, поэтому его можно использовать как ключ.
- **Для других типов (числа, строки, структуры, массивы)** `nil` не существует (у них свои нулевые значения, например, `0`, `""` и т.д.).

#### Примеры

```go
// 1. Указатель (nil - валидный ключ)
m := map[*int]string{
    nil: "this is nil",
}
fmt.Println(m[nil]) // Выведет: "this is nil"

// 2. Канал (nil - валидный ключ)
chMap := map[chan int]string{
    nil: "nil channel",
}
fmt.Println(chMap[nil]) // Выведет: "nil channel"

// 3. Интерфейс (nil - валидный ключ)
var iface interface{}
ifaceMap := map[interface{}]string{
    iface: "nil interface",
}
fmt.Println(ifaceMap[nil]) // Выведет: "nil interface"

// 4. Срез (nil - валидный ключ, но срезы НЕЛЬЗЯ использовать как ключи)
//    Компилятор выдаст ошибку: "invalid map key type []int"
//    Но технически nil-срез можно использовать, если обернуть в интерфейс (не рекомендуется)
var nilSlice []int
invalidMap := map[interface{}]string{
    nilSlice: "nil slice (hidden in interface)",
}
fmt.Println(invalidMap[nilSlice]) // Работает, но это хак!
```

### Почему срезы нельзя использовать как ключи, а массивы — можно?

- **Срезы (`[]T`)** — **не сравнимы** (не поддерживают `==`), так как они:
    
    - Ссылаются на **базовый массив**, который может меняться.
    - Имеют **нефиксированную длину**.
- **Массивы (`[N]T`)** — **сравнимы**, так как:
    - Имеют **фиксированный размер**.
    - Значения всех элементов **явно хранятся** в них.

## Каков порядок перебора в Map в Go?

Порядок перебора в map в Go: **Случайный и намеренно недетерминированный**

В Go **порядок перебора элементов в `map` (при использовании `range`) специально сделан случайным**, начиная с версии **Go 1.0**. Это не баг, а фича, и у разработчиков языка есть веские причины для такого решения.

### Официальная аргументация из документации Go

Это решение отражает философию Go:

> _"Явное лучше неявного. Надежность важнее удобства."_

#### Защита от неявных зависимостей

Разработчики Go считают, что если порядок перебора будет фиксированным, программисты начнут неосознанно полагаться на него, что может привести:

- К хрупкому коду, который сломается при изменении реализации `map` в будущем.
- К ошибкам, когда код работает только при "правильном" порядке ключей.

> _"The iteration order is not specified and is not guaranteed to be the same from one iteration to the next."_  
> — [Effective Go](https://go.dev/doc/effective_go#maps)

#### Предотвращение атак, связанных с хеш-коллизиями

Если злоумышленник знает порядок перебора (например, в веб-фреймворках, где `map` используется для параметров запроса), он может спровоцировать коллизии хешей и замедлить работу сервера (атака **HashDoS**).  
Случайный порядок усложняет предсказание структуры `map`.

> _"Making the iteration order random is a security feature to prevent denial-of-service attacks that rely on predictable hash table behavior."_  
> — [Commit ersche 2011](https://github.com/golang/go/commit/0c3f0bc8a3b0a0218a0c4e2e7f8b7e5b8d5b5b5b)

#### Упрощение оптимизаций в рантайме

Реализация `map` в Go (например, хеш-таблица с "бакетами" и динамическим ростом) может меняться. Случайный порядок позволяет:

- Менять алгоритмы хеширования и рехеширования без обратной совместимости.
- Улучшать производительность, не беспокоясь о сохранении порядка.

> _"The runtime randomizes the starting bucket and the iteration order within the bucket."_  
> — [Go Map Internals (blog)](https://go.dev/blog/maps)

### Как добиться детерминированного порядка

Если порядок важен, нужно **сортировать ключи** перед перебором:

```go
keys := make([]string, 0, len(m))
for k := range m {
    keys = append(keys, k)
}
sort.Strings(keys) // Сортируем ключи

for _, k := range keys {
    fmt.Println(k, m[k]) // Всегда одинаковый порядок
}
```

---

# Swiss Tables — новая реализация Map (Go 1.24)

> Источники: [go.dev/blog/swisstable](https://go.dev/blog/swisstable) · [Datadog case study](https://www.datadoghq.com/blog/engineering/go-swiss-tables/)

## Предыстория

Оригинальная реализация Go map (до 1.24) — хэш-таблица с **chaining через overflow buckets**:
- Каждый бакет содержит 8 слотов key-value.
- При переполнении → ссылка на overflow bucket.
- Load factor ≤ 6.5 (после которого начинается рехеширование).

В 2017 году инженеры Google создали новый дизайн хэш-таблицы **Swiss Tables** для C++ (открыт в библиотеке Abseil). В Go 1.24 эта идея была реализована нативно.

## Структура Swiss Table

Данные хранятся в **группах**. Каждая группа:
- **8 слотов** для пар key-value.
- **64-битное control word** (8 байт = 1 байт на слот).

```
Группа:
┌──────────────────────────────────────────────────┐
│ Control Word (64 bit):                           │
│  [h2_0][h2_1][h2_2][h2_3][h2_4][h2_5][h2_6][h2_7] │
│   1байт 1байт 1байт 1байт 1байт 1байт 1байт 1байт  │
│                                                  │
│ Slots: [K0,V0][K1,V1][K2,V2]...[K7,V7]          │
└──────────────────────────────────────────────────┘
```

**Формат байта control word:**
- `0b0_xxxxxxx` — слот **занят**, `xxxxxxx` = 7 бит хэша (h2).
- `0b10000000` — слот **пустой** (empty).
- `0b11111110` — слот **удалён** (tombstone).

## Алгоритм хэширования и поиска

При поиске ключа вычисляется 64-битный хэш, который делится на две части:

```
hash(key) = [h1: 57 бит | h2: 7 бит]
```

1. **h1** определяет **начальную группу**: `group_index = h1 mod N`.
2. **h2** сравнивается со всеми 8 байтами control word **параллельно** (SIMD).
3. Совпавшие слоты — кандидаты для полного сравнения ключей.
4. При промахе → **квадратичный пробинг** к следующей группе.

### SIMD-параллелизм

На аппаратном уровне сравнение `h2` со всеми 8 слотами — **одна инструкция**:

```
Control Word: [h2_A][h2_B][h2_C][h2_D][h2_E][h2_F][h2_G][h2_H]
Target h2:   [h2_T][h2_T][h2_T][h2_T][h2_T][h2_T][h2_T][h2_T]
Result mask: [  0 ][  1 ][  0 ][  0 ][  1 ][  0 ][  0 ][  0 ]
               ↑ не совпало  ↑ совпало → проверяем полный ключ
```

На amd64 реализовано через 8-байтные SIMD-операции. В будущем — 16-байтные (16 слотов за раз).

## Extendible Hashing — масштабирование больших мап

Одна Swiss Table ограничена **128 группами (1024 слотов)**. Для больших мап Go 1.24 использует **extendible hashing**:

```
Map
├── Table 0 [ключи: h1 начинается с 0...]
├── Table 1 [ключи: h1 начинается с 1...]
└── Table N [...]
```

Это позволяет:
- Расти инкрементально (не рехешируем всё сразу).
- Независимо расти отдельным таблицам.

## Итерация во время модификации

Спецификация Go разрешает изменять map во время range — Swiss Tables поддерживают это:

```go
m := map[string]int{"a": 1, "b": 2, "c": 3}
for k := range m {
    if k == "b" {
        delete(m, "c") // допустимо
    }
}
```

Итератор держит ссылку на старую таблицу. При росте — консультируется с новой, чтобы убедиться что элемент ещё жив.

## Load Factor

| Реализация | Load Factor | Описание |
|------------|-------------|---------|
| Go ≤ 1.23 | 6.5 / 8 = **81.25%** | После которого рехеш |
| Go 1.24+ (Swiss) | 7 / 8 = **87.5%** | Квадратичный пробинг эффективнее |

Более высокий LF = меньше памяти при том же числе элементов.

## Производительность

| Операция | Go 1.23 | Go 1.24 (Swiss) | Ускорение |
|----------|---------|-----------------|-----------|
| Lookup | baseline | | **до 60%** быстрее |
| Insert | baseline | | **до 60%** быстрее |
| Delete | baseline | немного медленнее* | |
| Общий CPU overhead рантайма | baseline | | **-2–3%** |

\* Delete немного дороже из-за дополнительной работы по оптимизации памяти.

**Реальный кейс (Datadog):**
- Экономия ~500 MiB live heap на одной map `shardRoutingCache`.
- С учётом GOGC=100 → **-1 GiB** реального потребления памяти.
- Итого: **~70% снижение** памяти для крупных мап.

## Сравнение Old Map vs Swiss Map

| Характеристика | Old Map (≤ 1.23) | Swiss Map (1.24+) |
|----------------|-----------------|------------------|
| Структура | Buckets + overflow chains | Groups с control word |
| Слотов в группе/бакете | 8 | 8 |
| Разрешение коллизий | Chaining (overflow buckets) | Quadratic probing |
| SIMD lookup | Нет | Да (amd64) |
| Load factor | 6.5/8 = 81.25% | 7/8 = 87.5% |
| Overhead overflow buckets | Да | Нет |
| Память на больших мап | Больше | Меньше |
| Source code | `map_noswiss.go` | `map_swiss.go` |

## Обратная совместимость

Обновление до Go 1.24 — **код менять не нужно**. Все `map[K]V` автоматически используют Swiss Tables. Поведение с точки зрения Go-спецификации не изменилось.

```go
// Этот код работает одинаково на Go 1.23 и Go 1.24+
m := make(map[string]int)
m["key"] = 42
v := m["key"]
delete(m, "key")
```

## Структура исходного кода

```
runtime/
├── map_swiss.go      // Swiss Tables реализация (Go 1.24+)
├── map_noswiss.go    // Старая реализация
└── map.go            // Общий интерфейс
```
