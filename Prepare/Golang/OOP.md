# ООП (Объектно-ориентированное программирование)

## Что это

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на представлении программы как совокупности **объектов**, которые взаимодействуют друг с другом. Каждый объект — это экземпляр **класса**, содержащего **данные** (поля) и **поведение** (методы).

## Основные концепции ООП

1. **Инкапсуляция** — скрытие внутренней реализации объекта, доступ только через интерфейс (методы).
2. **Наследование** — возможность создавать новые классы на основе существующих.
3. **Полиморфизм** — способность объектов использовать один интерфейс, но разную реализацию.
4. **Абстракция** — выделение существенного, скрытие деталей.

## Плюсы ООП

- **Повторное использование кода** (через наследование).
- **Модульность** (программу легко разбить на независимые классы).
- **Упрощение поддержки и расширяемости кода**.
- **Естественное моделирование реальных сущностей**.

##  Минусы ООП

- **Избыточность** при простых задачах.
- **Сложность проектирования архитектуры** (легко сделать плохо).
- **Производительность** (ООП может быть медленнее из-за абстракций).
- **Множественное наследование** (в языках, где оно разрешено) может приводить к конфликтам.

## ООП в Go

Go не является классическим объектно-ориентированным языком, как Java или C++, но он реализует **некоторые принципы ООП**.

| Концепция ООП | Есть в Go?  | Как реализуется                  |
| ------------- | ----------- | -------------------------------- |
| Инкапсуляция  | ✅           | Через экспорт/неэкспорт и методы |
| Наследование  | ⚠️ Частично | Через композицию (embedding)     |
| Полиморфизм   | ✅           | Интерфейсы                       |
| Абстракция    | ✅           | Интерфейсы, композиция           |

### Что есть в Go

#### Композиция вместо наследования (встраивание)

Go не поддерживает наследование в классическом смысле. Вместо этого используется **встраивание (embedding)** — когда одна структура включает другую, унаследовав её методы.

```go
type Animal struct {
    Name string
}

func (a Animal) Speak() {
    fmt.Println(a.Name + " makes a sound")
}

type Dog struct {
    Animal
}

func main() {
    d := Dog{Animal{"Rex"}}
    d.Speak() // Rex makes a sound
}
```

#### Интерфейсы и полиморфизм

Интерфейсы в Go позволяют достичь **полиморфизма**. Если тип реализует все методы интерфейса — он считается его реализацией (без явного указания).

```go
type Speaker interface {
    Speak()
}

func MakeItSpeak(s Speaker) {
    s.Speak()
}
```

#### Инкапсуляция

В Go **первый символ имени** определяет уровень доступа:
- с **заглавной буквы** — экспортируется (публично),
- с **маленькой** — приватно (в пределах пакета).

#### Абстракция

Через интерфейсы и скрытие деталей реализации — Go позволяет описывать поведение без указания конкретных типов.

### Что отсутствует в Go

- **Классы и наследование** (в классическом смысле).
- **Перегрузка методов и операторов**.
- **Множественное наследование** (что, кстати, многие считают плюсом — проще и безопаснее).

### Пример

```go
package main

import "fmt"

// Интерфейс
type Speaker interface {
	Speak()
}

// Структура
type Dog struct {
	Name string
}

// Метод для структуры Dog
func (d Dog) Speak() {
	fmt.Println(d.Name, "says Woof!")
}

// Ещё одна структура
type Cat struct {
	Name string
}

func (c Cat) Speak() {
	fmt.Println(c.Name, "says Meow!")
}

// Функция, принимающая любой тип, реализующий интерфейс Speaker
func MakeSpeak(s Speaker) {
	s.Speak()
}

func main() {
	d := Dog{"Rex"}
	c := Cat{"Mittens"}

	MakeSpeak(d)
	MakeSpeak(c)
}

// Output:
// Rex says Woof!
// Mittens says Meow!
```
